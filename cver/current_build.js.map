{"version":3,"file":"../current_build.js","sources":["../units/adsr.c","../wslib/associativearray.c","../platform/audiohandler.c","../wslib/context.c","../wslib/desktop.c","../uilib/frame.c","../core/io.c","../wslib/list.c","../wslib/listnode.c","../main.c","../units/masterout.c","../uilib/menu.c","../uilib/menuentry.c","../core/module.c","../units/noise.c","../wslib/object.c","../core/patchcore.c","../widgets/patchdesktop.c","../units/pitchknob.c","../platform/platformwrapper_emscripten.c","../wslib/rect.c","../units/scope.c","../units/sequence.c","../widgets/sessionmenu.c","../units/sine.c","../uilib/slider.c","../units/split.c","../units/square.c","../wslib/styleutils.c","../core/unit.c","../units/vca.c","../wslib/window.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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A;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAQA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AACA;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;;AAEA;;AADA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAoMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA","sourcesContent":["#include \"adsr.h\"\n#include <math.h>\n\nModule* ADSR_new() {\n\n    return Module_new(ADSR_constructor, \"ADSR\");\n}\n\nint ADSR_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n    \n    float current_gain;\n    float in_sample_l, in_sample_r, gate_sample, a_sample, d_sample, s_sample, r_sample;\n    \n    ADSR* adsr = (ADSR*)io->param_object;\n\n    if(!IO_pull_sample(adsr->input,  &in_sample_l, &in_sample_r, &gate_sample))\n        return 0;\n\n    a_sample = Slider_get_value(adsr->a_slider);\n    d_sample = Slider_get_value(adsr->d_slider);\n    s_sample = Slider_get_value(adsr->s_slider);\n    r_sample = Slider_get_value(adsr->r_slider);\n\n    if(gate_sample > -1.0) {\n\n        //Check to see if we just turned on\n        if(!(adsr->last_gate > -1.0)) {\n\n            adsr->time = 0;\n        }\n\n        if(adsr->time <= a_sample) {\n\n            current_gain = (powf(adsr->time/a_sample, 2) * 2) - 1;\n            adsr->time += 1000.0/SAMPLE_RATE;\n        } else if(adsr->time <= (a_sample + d_sample))  {\n\n            current_gain = (((powf((((2*(a_sample+(d_sample/2))) - adsr->time) - a_sample)/d_sample, 2) * ((1 - s_sample) / 2)) + (1 - ((1 - s_sample) / 2))) * 2) - 1;\n            adsr->time += 1000.0/SAMPLE_RATE;\n        } else {\n\n            current_gain = s_sample;\n\n            //Don't increase time because it doesn't matter anymore\n        }\n             \n    } else {\n  \n        //Check to see if we just turned off\n        if(adsr->last_gate > -1.0) {\n\n            adsr->time = 0;\n        }\n\n        if(adsr->time <= r_sample) {\n        \n            current_gain = (((powf(((2 * (r_sample / 2)) - adsr->time) / r_sample, 2) * (1 - ((1 - s_sample) / 2))) * 2) - 1);\n            adsr->time += 1000.0/SAMPLE_RATE;\n        } else {\n        \n            current_gain = -1.0;\n            //Don't increase time because it doesn't matter anymore\n        }\n    }\n\n    adsr->last_gate = gate_sample;\n    *sample_g = 1;\n    *sample_l = *sample_r = current_gain;\n \n    return 1;\n}\n\nvoid ADSR_paint_handler(Window* sine_window) {\n\n    Frame_paint_handler(sine_window);\n    /*\n    Context_draw_text(sine_window->context, \"ADSR\",\n                       (sine_window->width / 2) - 16,\n                       (sine_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n                       */\n}\n\nUnit* ADSR_constructor(PatchCore* patch_core) {\n\n    ADSR* adsr = (ADSR*)malloc(sizeof(ADSR));\n\n    if(!adsr)\n        return (Unit*)adsr;\n\n    if(!Unit_init((Unit*)adsr, patch_core)) {\n\n        Object_delete((Object*)adsr);\n        return (Unit*)0;\n    }\n\n    adsr->a_slider = Slider_new(10, 10, 30, 130, 0.01, 1000);\n    adsr->d_slider = Slider_new(50, 10, 30, 130, 0.01, 1000);\n    adsr->s_slider = Slider_new(90, 10, 30, 130, -1, 1);\n    adsr->r_slider = Slider_new(130, 10, 30, 130, 0.01, 1000);\n    adsr->output = Unit_create_output((Unit*)adsr, 195, 75);\n    adsr->input = Unit_create_input((Unit*)adsr, 5, 75);\n    Window_resize((Window*)adsr, 200, 150);\n\n    if(!(adsr->output && adsr->input && adsr->a_slider && adsr->d_slider &&\n       adsr->s_slider && adsr->r_slider)) {\n\n        Object_delete((Object*)adsr);\n        return (Unit*)0;\n    }    \n   \n    Window_insert_child((Window*)adsr, (Window*)adsr->a_slider);\n    Window_insert_child((Window*)adsr, (Window*)adsr->d_slider);\n    Window_insert_child((Window*)adsr, (Window*)adsr->s_slider);\n    Window_insert_child((Window*)adsr, (Window*)adsr->r_slider);\n    adsr->time = 0;\n    adsr->last_gate = -1.0;\n    adsr->output->pull_sample_function = ADSR_pull_sample_handler;\n    adsr->unit.frame.window.paint_function = ADSR_paint_handler;\n\n    return (Unit*)adsr;\n}\n","#include \"associativearray.h\"\n#include <stdlib.h>\n\nAssociativeArray* AssociativeArray_new() {\n\n    AssociativeArray* associative_array =\n        (AssociativeArray*)malloc(sizeof(AssociativeArray));\n\n    if(!associative_array)\n        return associative_array;\n\n    Object_init((Object*)associative_array, AssociativeArray_delete_function);\n    associative_array->keys = List_new();\n    associative_array->values = List_new();\n\n    if(!(associative_array->keys && associative_array->values)) {\n\n        Object_delete((Object*)associative_array);\n        return (AssociativeArray*)0;\n    }\n\n    return associative_array;\n}\n\nvoid AssociativeArray_delete_function(Object* associative_array_object) {\n\n    AssociativeArray* associative_array;\n\n    if(!associative_array_object)\n        return;\n\n    associative_array = (AssociativeArray*)associative_array_object;\n\n    Object_delete((Object*)associative_array->keys);\n    Object_delete((Object*)associative_array->values);\n    Object_default_delete_function(associative_array_object);\n}\n\nObject* AssociativeArray_get(AssociativeArray* associative_array, String* key) {\n\n    int i;\n\n    for(i = 0; i < associative_array->keys->count; i++)\n        if(String_compare((String*)List_get_at(associative_array->keys, i), key))\n            break;\n\n    if(i == associative_array->keys->count)\n        return (Object*)0;\n\n    return List_get_at(associative_array->values, i);\n}\n\nint AssociativeArray_add(AssociativeArray* associative_array, String* key, Object* value) {\n\n    if(!List_add(associative_array->keys, (Object*)key))\n        return 0;\n    \n    return List_add(associative_array->values, value);\n}\n","#include \"audiohandler.h\"\n#include <stdlib.h>\n\nAudioHandler* AudioHandler_new(AudioHandlerFunction function, Object* parent_object) {\n\n    AudioHandler* audio_handler;\n    if(!(audio_handler = (AudioHandler*)malloc(sizeof(AudioHandler))))\n        return audio_handler;\n\n    Object_init((Object*)audio_handler, 0);\n    audio_handler->function = function;\n    audio_handler->parent_object = parent_object;\n\n    return audio_handler;\n}\n","#include <inttypes.h>\n#include \"context.h\"\n#include \"rect.h\"\n#include \"font.h\"\n\n\n//================| Context Class Implementation |================//\n\n//Constructor for our context\nContext* Context_new(uint16_t width, uint16_t height, uint32_t* buffer) {\n\n    static unsigned int handle_source = 0;\n\n    //Attempt to allocate\n    Context* context;\n    if(!(context = (Context*)malloc(sizeof(Context))))\n        return context; \n\n    //Init base object\n    Object_init((Object*)context, Context_delete_function);\n\n    //Attempt to allocate new rect list \n    if(!(context->clip_rects = List_new())) {\n\n        free(context);\n        return (Context*)0;\n    }\n\n    //Finish assignments\n    context->id = ++handle_source;\n    context->translate_x = 0;\n    context->translate_y = 0;\n    context->width = width; \n    context->height = height; \n    context->buffer = buffer;\n    context->clipping_on = 0;\n\n    return context;\n}\n\n//Clone from another context\nContext* Context_new_from(Context* source_context) {\n\n    return Context_new(source_context->width, source_context->height, source_context->buffer);\n}\n\nvoid Context_delete_function(Object* context_object) {\n\n    Context* context = (Context*)context_object;\n\n    if(!context_object)\n        return;\n\n    Object_delete((Object*)context->clip_rects);\n    free(context);\n}\n\nvoid Context_clipped_rect(Context* context, int x, int y, unsigned int width,\n                          unsigned int height, Rect* clip_area, uint32_t color) {\n\n    int cur_x;\n    int max_x = x + width;\n    int max_y = y + height;\n\n    //Translate the rectangle coordinates by the context translation values\n    x += context->translate_x;\n    y += context->translate_y;\n    max_x += context->translate_x;\n    max_y += context->translate_y;\n\n    //Make sure we don't go outside of the clip region:\n    if(x < clip_area->left)\n        x = clip_area->left;\n    \n    if(y < clip_area->top)\n        y = clip_area->top;\n\n    if(max_x > clip_area->right + 1)\n        max_x = clip_area->right + 1;\n\n    if(max_y > clip_area->bottom + 1)\n        max_y = clip_area->bottom + 1;\n\n    //Draw the rectangle into the framebuffer line-by line\n    //(bonus points if you write an assembly routine to do it faster)\n    for(; y < max_y; y++) \n        for(cur_x = x; cur_x < max_x; cur_x++) \n            context->buffer[y * context->width + cur_x] = color;\n}\n\n//Simple for-loop rectangle into a context\nvoid Context_fill_rect(Context* context, int x, int y,  \n                      unsigned int width, unsigned int height, uint32_t color) {\n\n    int max_x = x + width;\n    int max_y = y + height;\n    int i;\n    Rect* clip_area;\n    Rect screen_area;\n\n    //Fix from last time: Make sure we don't try to draw offscreen\n    if(max_x > context->width)\n        max_x = context->width;\n\n    if(max_y > context->height)\n        max_y = context->height;\n   \n    if(x < 0)\n        x = 0;\n    \n    if(y < 0)\n        y = 0;\n    \n    width = max_x - x;\n    height = max_y - y;    \n\n    //If there are clipping rects, draw the rect clipped to\n    //each of them. Otherwise, draw unclipped (clipped to the screen)\n    if(context->clip_rects->count) {\n       \n        for(i = 0; i < context->clip_rects->count; i++) {    \n\n            clip_area = (Rect*)List_get_at(context->clip_rects, i);\n            Context_clipped_rect(context, x, y, width, height, clip_area, color);\n        }\n    } else {\n\n        if(!context->clipping_on) {\n\n            screen_area.top = 0;\n            screen_area.left = 0;\n            screen_area.bottom = context->height - 1;\n            screen_area.right = context->width - 1;\n            Context_clipped_rect(context, x, y, width, height, &screen_area, color);\n        }\n    }\n}\n\n//A horizontal line as a filled rect of height 1\nvoid Context_horizontal_line(Context* context, int x, int y,\n                             unsigned int length, uint32_t color) {\n\n    Context_fill_rect(context, x, y, length, 1, color);\n}\n\n//A vertical line as a filled rect of width 1\nvoid Context_vertical_line(Context* context, int x, int y,\n                           unsigned int length, uint32_t color) {\n\n    Context_fill_rect(context, x, y, 1, length, color);\n}\n\n//Rectangle drawing using our horizontal and vertical lines\nvoid Context_draw_rect(Context* context, int x, int y, \n                       unsigned int width, unsigned int height, uint32_t color) {\n\n    Context_horizontal_line(context, x, y, width, color); //top\n    Context_vertical_line(context, x, y + 1, height - 2, color); //left \n    Context_horizontal_line(context, x, y + height - 1, width, color); //bottom\n    Context_vertical_line(context, x + width - 1, y + 1, height - 2, color); //right\n}\n\n//Update the clipping rectangles to only include those areas within both the\n//existing clipping region AND the passed Rect\nvoid Context_intersect_clip_rect(Context* context, Rect* rect) {\n\n    int i;\n    List* output_rects;\n    Rect* current_rect;\n    Rect* intersect_rect;\n \n    context->clipping_on = 1;\n\n    if(!(output_rects = List_new()))\n        return;\n\n    for(i = 0; i < context->clip_rects->count; i++) {\n\n        current_rect = (Rect*)List_get_at(context->clip_rects, i);\n        intersect_rect = Rect_intersect(current_rect, rect);\n\n        if(intersect_rect)\n            List_add(output_rects, (Object*)intersect_rect);\n    }\n\n    //Delete the original rectangle list\n    Object_delete((Object*)context->clip_rects);\n\n    //And re-point it to the new one we built above\n    context->clip_rects = output_rects;\n\n    //Free the input rect\n    Object_delete((Object*)rect);\n}\n\n//split all existing clip rectangles against the passed rect\nvoid Context_subtract_clip_rect(Context* context, Rect* subtracted_rect) {\n\n    //Check each item already in the list to see if it overlaps with\n    //the new rectangle\n    int i, j;\n    Rect* cur_rect;\n    List* split_rects;\n\n    context->clipping_on = 1;\n\n    for(i = 0; i < context->clip_rects->count; ) {\n\n        cur_rect = (Rect*)List_get_at(context->clip_rects, i);\n\n        //Standard rect intersect test (if no intersect, skip to next)\n        //see here for an example of why this works:\n        //http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other#tab-top\n        if(!(cur_rect->left <= subtracted_rect->right &&\n\t\t   cur_rect->right >= subtracted_rect->left &&\n\t\t   cur_rect->top <= subtracted_rect->bottom &&\n\t\t   cur_rect->bottom >= subtracted_rect->top)) {\n\n            i++;\n            continue;\n        }\n\n        //If this rectangle does intersect with the new rectangle, \n        //we need to split it\n        List_remove_at(context->clip_rects, i); //Original will be replaced w/splits\n        split_rects = Rect_split(cur_rect, subtracted_rect); //Do the split\n        Object_delete((Object*)cur_rect); //We can throw this away now, we're done with it\n\n        //Copy the split, non-overlapping result rectangles into the list \n        while(split_rects->count) {\n\n            cur_rect = (Rect*)List_remove_at(split_rects, 0);\n            List_add(context->clip_rects, (Object*)cur_rect);\n        }\n\n        //Free the empty split_rect list \n        Object_delete((Object*)split_rects);\n\n        //Since we removed an item from the list, we need to start counting over again \n        //In this way, we'll only exit this loop once nothing in the list overlaps \n        i = 0;    \n    }\n}\n\nvoid Context_add_clip_rect(Context* context, Rect* added_rect) {\n    \n    Context_subtract_clip_rect(context, added_rect);\n\n    //Now that we have made sure none of the existing rectangles overlap\n    //with the new rectangle, we can finally insert it \n    List_add(context->clip_rects, (Object*)added_rect);\n}\n\n//Remove all of the clipping rects from the passed context object\nvoid Context_clear_clip_rects(Context* context) {\n\n    Rect* cur_rect;\n\n    context->clipping_on = 0;\n\n    while(context->clip_rects->count)\n        Object_delete(List_remove_at(context->clip_rects, 0)); \n}\n\n//Draw a single character with the specified font color at the specified coordinates\nvoid Context_draw_char_clipped(Context* context, char character, int x, int y,\n                               uint32_t color, Rect* bound_rect) {\n\n    int font_x, font_y;\n    int off_x = 0;\n    int off_y = 0;\n    int count_x = 8; //Font is 8x12\n    int count_y = 12; \n    uint8_t shift_line;\n\n    //Make sure to take context translation into account\n    x += context->translate_x;\n    y += context->translate_y;\n\n    //Our font only handles the core set of 128 ASCII chars\n    character &= 0x7F;\n\n    //Check to see if the character is even inside of this rectangle\n    if(x > bound_rect->right || (x + 8) <= bound_rect->left ||\n       y > bound_rect->bottom || (y + 12) <= bound_rect->top)\n        return;\n\n    //Limit the drawn portion of the character to the interior of the rect\n    if(x < bound_rect->left)\n        off_x = bound_rect->left - x;        \n\n    if((x + 8) > bound_rect->right)\n        count_x = bound_rect->right - x + 1;\n\n    if(y < bound_rect->top)\n        off_y = bound_rect->top - y;\n\n    if((y + 12) > bound_rect->bottom)\n        count_y = bound_rect->bottom - y + 1;\n\n    //Now we do the actual pixel plotting loop\n    for(font_y = off_y; font_y < count_y; font_y++) {\n\n        //Capture the current line of the specified char\n        //Just a normal bmp[y * width + x], but in this\n        //case we're dealing with an array of 1bpp\n        //8-bit-wide character lines\n        shift_line = font_array[font_y * 128 + character];\n\n        //Pre-shift the line by the x-offset\n        shift_line <<= off_x;\n\n        for(font_x = off_x; font_x < count_x; font_x++) {\n\n            //Get the current leftmost bit of the current \n            //line of the character and, if it's set, plot a pixel\n            if(shift_line & 0x80)\n                context->buffer[(font_y + y) * context->width + (font_x + x)] = color;\n \n            //Shift in the next bit\n            shift_line <<= 1; \n        }\n    }\n}\n\n//This will be a lot like Context_fill_rect, but on a bitmap font character\nvoid Context_draw_char(Context* context, char character, int x, int y, uint32_t color) {\n\n    int i;\n    Rect* clip_area;\n    Rect screen_area;\n\n    //If there are clipping rects, draw the character clipped to\n    //each of them. Otherwise, draw unclipped (clipped to the screen)\n    if(context->clip_rects->count) {\n       \n        for(i = 0; i < context->clip_rects->count; i++) {    \n\n            clip_area = (Rect*)List_get_at(context->clip_rects, i);\n            Context_draw_char_clipped(context, character, x, y, color, clip_area);\n        }\n    } else {\n\n        if(!context->clipping_on) {\n\n            screen_area.top = 0;\n            screen_area.left = 0;\n            screen_area.bottom = context->height - 1;\n            screen_area.right = context->width - 1;\n            Context_draw_char_clipped(context, character, x, y, color, clip_area);\n        }\n    }\n}\n\n//Draw a line of text with the specified font color at the specified coordinates\nvoid Context_draw_text(Context* context, char* string, int x, int y, uint32_t color) {\n\n    for( ; *string; x += 8)\n        Context_draw_char(context, *(string++), x, y, color);\n}\n","#include <inttypes.h>\n#include <stdlib.h>\n#include \"desktop.h\"\n#include \"rect.h\"\n\n\n//================| Desktop Class Implementation |================//\n\n//Mouse image data\n#define CA 0xFF000000 //Black\n#define CB 0xFFFFFFFF //White\n#define CD 0x00000000 //Clear\n\nunsigned int mouse_img[MOUSE_BUFSZ] = {\n    CA, CD, CD, CD, CD, CD, CD, CD, CD, CD, CD,\n    CA, CA, CD, CD, CD, CD, CD, CD, CD, CD, CD,\n    CA, CB, CA, CD, CD, CD, CD, CD, CD, CD, CD,\n    CA, CB, CB, CA, CD, CD, CD, CD, CD, CD, CD,\n    CA, CB, CB, CB, CA, CD, CD ,CD, CD, CD, CD,\n    CA, CB, CB, CB, CB, CA, CD, CD, CD, CD, CD,\n    CA, CB, CB, CB, CB, CB, CA, CD, CD, CD, CD,\n    CA, CB, CB, CB, CB, CB, CB, CA, CD, CD, CD,\n    CA, CB, CB, CB, CB, CB, CB, CB, CA, CD, CD,\n    CA, CB, CB, CB, CB, CB, CB, CB, CB, CA, CD,\n    CA, CB, CB, CB, CB, CB, CB, CB, CB, CB, CA,\n    CA, CA, CA, CA, CB, CB, CB, CA, CA, CA, CA,\n    CD, CD, CD, CD, CA, CB, CB, CA, CD, CD, CD,\n    CD, CD, CD, CD, CA, CB, CB, CA, CD, CD, CD,\n    CD, CD, CD, CD, CD, CA, CB, CB, CA, CD, CD,\n    CD, CD, CD, CD, CD, CA, CB, CB, CA, CD, CD,\n    CD, CD, CD, CD, CD, CD, CA, CB, CA, CD, CD,\n    CD, CD, CD, CD, CD, CD, CD, CA, CA, CD, CD \n};\n\nDesktop* Desktop_new(Context* context) {\n\n    //Malloc or fail \n    Desktop* desktop;\n    if(!(desktop = (Desktop*)malloc(sizeof(Desktop))))\n        return desktop;\n\n    if(!Desktop_init(desktop, context)) {\n\n        Object_delete((Object*)desktop);\n        return (Desktop*)0;\n    }\n\n    return desktop;\n}\n\nint Desktop_init(Desktop* desktop, Context* context) {\n\n    //Initialize the Window bits of our desktop\n    if(!Window_init((Window*)desktop, 0, 0, context->width, context->height,\n                    WIN_NODECORATION | WIN_NORAISE, context))\n        return 0;\n\n    //Override our paint function\n    desktop->window.paint_function = Desktop_paint_handler;\n\n    //Now continue by filling out the desktop-unique properties \n    desktop->window.last_button_state = 0;\n\n    //Init mouse to the center of the screen\n    desktop->mouse_x = desktop->window.context->width / 2;\n    desktop->mouse_y = desktop->window.context->height / 2;\n    desktop->mouse_shown = 1;\n\n    //Make sure the mouse always starts over the desktop\n    Window_mouseover((Window*)desktop);\n\n    return 1;\n}\n\n//Paint the desktop \nvoid Desktop_paint_handler(Window* desktop_window) {\n  \n    //Fill the desktop\n    Context_fill_rect(desktop_window->context, 0, 0, desktop_window->context->width, desktop_window->context->height, RGB(11, 162, 193));\n\n    //Draw some test text\n    Context_draw_text(desktop_window->context, \"Windowing Systems by Example\",\n                      0, desktop_window->height - 12, 0xFFFFFFFF);\n}\n\n//Our overload of the Window_process_mouse function used to capture the screen mouse position \nvoid Desktop_process_mouse(Desktop* desktop, uint16_t mouse_x,\n                           uint16_t mouse_y, uint8_t mouse_buttons) {\n\n    int i, x, y;\n    Window* child;\n    List* dirty_list;\n    Rect* mouse_rect;\n\n    //Do the old generic mouse handling\n    Window_process_mouse((Window*)desktop, mouse_x, mouse_y, mouse_buttons);\n\n    //Window painting now happens inside of the window raise and move operations\n    \n    //Exit early if the mouse is turned off\n    if(!desktop->mouse_shown)\n        return;\n\n    //Build a dirty rect list for the mouse area\n    if(!(dirty_list = List_new()))\n        return;\n\n    if(!(mouse_rect = Rect_new(desktop->mouse_y, desktop->mouse_x, \n                               desktop->mouse_y + MOUSE_HEIGHT - 1,\n                               desktop->mouse_x + MOUSE_WIDTH - 1))) {\n\n        free(dirty_list);\n        return;\n    }\n\n    List_add(dirty_list, (Object*)mouse_rect);\n\n    //Do a dirty update for the desktop, which will, in turn, do a \n    //dirty update for all affected child windows\n    Window_paint((Window*)desktop, dirty_list, 1); \n\n    //Clean up mouse dirty list\n    List_remove_at(dirty_list, 0);\n    free(dirty_list);\n    free(mouse_rect);\n\n    //Update mouse position\n    desktop->mouse_x = mouse_x;\n    desktop->mouse_y = mouse_y;\n\n    //No more hacky mouse, instead we're going to rather inefficiently \n    //copy the pixels from our mouse image into the framebuffer\n    for(y = 0; y < MOUSE_HEIGHT; y++) {\n\n        //Make sure we don't draw off the bottom of the screen\n        if((y + mouse_y) >= desktop->window.context->height)\n            break;\n\n        for(x = 0; x < MOUSE_WIDTH; x++) {\n\n            //Make sure we don't draw off the right side of the screen\n            if((x + mouse_x) >= desktop->window.context->width)\n                break;\n \n            //Don't place a pixel if it's transparent (still going off of ABGR here,\n            //change to suit your palette)\n            if(mouse_img[y * MOUSE_WIDTH + x] & 0xFF000000)\n                desktop->window.context->buffer[(y + mouse_y)\n                                                * desktop->window.context->width \n                                                + (x + mouse_x)\n                                               ] = mouse_img[y * MOUSE_WIDTH + x];\n        }\n    }\n}\n","#include \"frame.h\"\n\nFrame* Frame_new(int x, int y, int width, int height) {\n\n    Frame* frame;\n    if(!(frame = (Frame*)malloc(sizeof(Frame))))\n        return frame;\n\n    if(!Frame_init(frame, x, y, width, height)) {\n\n        free(frame);\n        return (Frame*)0;\n    }\n\n    return frame;\n}\n\nint Frame_init(Frame* frame, int x, int y, int width, int height) {\n\n    if(!Window_init((Window*)frame, x, y, width, height,\n                    WIN_BODYDRAG | WIN_NODECORATION, (Context*)0)) \n        return 0;\n\n    frame->window.paint_function = Frame_paint_handler;\n\n    return 1;\n}\n\nvoid Frame_paint_handler(Window* frame_window) {\n\n    Context_fill_rect(frame_window->context, 2, 2, frame_window->width - 4,\n                      frame_window->height - 4, RGB(155, 165, 185));\n    Context_draw_rect(frame_window->context, 0, 0, frame_window->width,\n                      frame_window->height, RGB(0, 0, 0));\n    Context_draw_rect(frame_window->context, 1, 1, frame_window->width - 2,\n                      frame_window->height - 2, RGB(0, 0, 0));\n}\n\n","#include \"io.h\"\n\n//NOTE: IOs need to automatically disconnect from anything they might be\n//      connected to upon deletion so that we don't get invalid pulls\n\nvoid IO_update_latches(IO* io) {\n\n    if(io->is_output || !io->connected_io)\n        return;\n\n    IO_pull_sample(io->connected_io,\n                   &io->latched_l_sample,\n                   &io->latched_r_sample,\n                   &io->latched_g_sample);\n}\n\nIO* IO_new(PatchCore* patch_core, Object* param_object, int x, int y, int is_output) {\n\n    IO* io = (IO*)malloc(sizeof(IO));\n    \n    if(!io)\n        return io;\n\n    if(!IO_init(io, patch_core, param_object, x, y, is_output)) {\n\n        Object_delete((Object*)io);\n        return (IO*)0;\n    }\n\n    if(is_output)\n        List_add(patch_core->outputs, (Object*)io);\n    else\n        List_add(patch_core->inputs, (Object*)io);\n\n    return io;\n}\n\nint IO_init(IO* io, PatchCore* patch_core, Object* param_object, int x, int y, int is_output) {\n\n    if(!Window_init((Window*)io, x - 3, y - 3, 6, 6,\n                    WIN_NODECORATION | WIN_NORAISE, (Context*)0)) \n        return 0;\n    \n    //Initial init\n    io->window.paint_function = IO_paint_handler;\n    io->window.mouseclick_function = IO_mouseclick_handler;\n    io->patch_core = patch_core; \n    io->param_object= param_object;\n    io->connected_io = (IO*)0;\n    io->is_output = is_output;\n    io->latched_l_sample = 0.0;\n    io->latched_r_sample = 0.0;\n    io->latched_g_sample = 0.0;\n    io->pull_sample_function = (IOSamplePullHandler)0;\n\n    return 1;\n}\n\nvoid IO_paint_handler(Window* io_window) {\n\n    IO* io = (IO*)io_window;\n\n    Context_fill_rect(io_window->context, 2, 2, 2, 2,\n                      io->connected_io ? RGB(0, 200, 0) : RGB(100, 100, 100));\n    Context_draw_rect(io_window->context, 0, 0, 6, 6, RGB(0, 0, 0));\n    Context_draw_rect(io_window->context, 1, 1, 4, 4, RGB(0, 0, 0));\n}\n\nvoid IO_mouseclick_handler(Window* io_window, int x, int y) {\n\n    IO* io = (IO*)io_window;\n\n    if(io->connected_io) {\n\n        io->connected_io->connected_io = (IO*)0;\n        Window_invalidate((Window*)io->connected_io, 0, 0,\n                          io->connected_io->window.height - 1,\n                          io->connected_io->window.width - 1);\n        io->connected_io = (IO*)0;\n    }\n\n    PatchCore_connect_action(io->patch_core, io);\n}\n\nvoid IO_connect(IO* io, IO* connected_io) {\n\n    io->connected_io = connected_io;\n}\n\nint IO_render_sample(IO* io) {\n\n    int retval;\n\n    if(!io->is_output || !io->pull_sample_function)\n        return 0;\n\n    return io->pull_sample_function(io,\n                                    &io->latched_l_sample,\n                                    &io->latched_r_sample,\n                                    &io->latched_g_sample);\n}\n\nint IO_pull_sample(IO* io, float *l_sample, float *r_sample, float *g_sample) {\n\n    *l_sample = io->latched_l_sample;\n    *r_sample = io->latched_r_sample;\n    *g_sample = io->latched_g_sample;\n\n    return 1;\n}\n","#include <inttypes.h>\n#include <stdlib.h>\n#include \"list.h\"\n\n\n//================| ListNode Class Implementation |================//\n\n//Basic list constructor\nList* List_new() {\n    \n    //Malloc and/or fail null\n    List* list;\n    if(!(list = (List*)malloc(sizeof(List))))\n        return list;\n\n    //Fill in initial property values\n    //(All we know for now is that we start out with no items) \n    Object_init((Object*)list, List_delete);\n    list->count = 0;\n    list->root_node = (ListNode*)0;\n\n    return list;\n}\n\n//Insert a payload at the end of the list\n//Zero is fail, one is success\nint List_add(List* list, Object* payload) {\n\n    //Try to make a new node, exit early on fail \n    ListNode* new_node;\n    if(!(new_node = ListNode_new(payload))) \n        return 0;\n\n    //If there aren't any items in the list yet, assign the\n    //new item to the root node\n    if(!list->root_node) {\n \n        list->root_node = new_node;        \n    } else {\n\n        //Otherwise, we'll find the last node and add our new node after it\n        ListNode* current_node = list->root_node;\n\n        //Fast forward to the end of the list \n        while(current_node->next)\n            current_node = current_node->next;\n\n        //Make the last node and first node point to each other\n        current_node->next = new_node;\n        new_node->prev = current_node; \n    }\n\n    //Update the number of items in the list and return success\n    list->count++;\n\n    return 1;\n}\n\n//Get the payload of the list item at the given index\n//Indices are zero-based\nObject* List_get_at(List* list, unsigned int index) {\n\n    unsigned int current_index;\n    ListNode* current_node;\n\n    //If there's nothing in the list or we're requesting beyond the end of\n    //the list, return nothing\n    if(list->count == 0 || index >= list->count) \n        return (Object*)0;\n\n    //Iterate through the items in the list until we hit our index\n    current_node = list->root_node;\n\n    //Iteration, making sure we don't hang on malformed lists\n    for(current_index = 0; (current_index < index) && current_node; current_index++)\n        current_node = current_node->next;\n\n    //Return the payload, guarding against malformed lists\n    return current_node ? current_node->payload : (Object*)0;\n}\n\n//Remove the item at the specified index from the list and return the item that\n//was removed\n//Indices are zero-based\nObject* List_remove_at(List* list, unsigned int index) {\n\n    //This operates very similarly to List_get_at\n\n    Object* payload; \n    ListNode* current_node;\n    unsigned int current_index;\n\n    //Bounds check\n    if(list->count == 0 || index >= list->count) \n        return (Object*)0;\n\n    //Iterate through the items\n    current_node = list->root_node;\n\n    for(current_index = 0; (current_index < index) && current_node; current_index++)\n        current_node = current_node->next;\n\n    //This is where we differ from List_get_at by stashing the payload,\n    //re-pointing the current node's neighbors to each other and \n    //freeing the removed node \n\n    //Return early if we got a null node somehow\n    if(!current_node)\n        return (Object*)0;\n\n    //Stash the payload so we don't lose it when we delete the node     \n    payload =  current_node->payload;\n \n    //Re-point neighbors to each other \n    if(current_node->prev)\n        current_node->prev->next = current_node->next;\n\n    if(current_node->next)\n        current_node->next->prev = current_node->prev;\n\n    //If the item was the root item, we need to make\n    //the node following it the new root\n    if(index == 0)\n        list->root_node = current_node->next;\n\n    //Now that we've clipped the node out of the list, we must free its memory\n    Object_delete((Object*)current_node); \n\n    //Make sure the count of items is up-to-date\n    list->count--; \n\n    //Finally, return the payload\n    return payload;\n}\n\n//Delete a list as well as any items which it still contains\n//As such, shouldn't be used if there are any objects in the \n//list referenced elsewhere or else you'll have dangling pointer\n//issues\nvoid List_delete(Object* list_object) {\n\n    List* list = (List*)list_object;\n\n    if(!list_object)\n        return;\n\n    //Remove each item from the list and pass it to its deleter\n    while(list->count)\n        Object_delete(List_remove_at(list, 0));\n\n    //And delete the list itself\n    free(list);\n}\n","#include <inttypes.h>\n#include <stdlib.h>\n#include \"listnode.h\"\n\n\n//================| ListNode Class Implementation |================//\n\n//Basic listnode constructor\nListNode* ListNode_new(Object* payload) {\n\n    //Malloc and/or fail null\n    ListNode* list_node;\n    if(!(list_node = (ListNode*)malloc(sizeof(ListNode))))\n        return list_node;\n\n    //Assign initial properties\n    Object_init((Object*)list_node, 0);\n    list_node->prev = (ListNode*)0;\n    list_node->next = (ListNode*)0;\n    list_node->payload = payload; \n\n    return list_node;\n}\n\n","#include \"platform/platformwrapper.h\"\n#include \"core/patchcore.h\"\n\nint main(int argc, char* argv[]) {\n\n    PlatformWrapper_init();\n    PatchCore_start(PatchCore_new());\n\n    PlatformWrapper_hold_for_exit();\n\n    return 0;\n}","#include \"math.h\"\n#include \"masterout.h\"\n\nModule* MasterOut_new() {\n\n    return Module_new(MasterOut_constructor, \"Master Out\");\n}\n\nfloat db2gain(float value) {\n\n    float max_db = 10;\n    float min_db = -80;\n    float db_value = ((max_db - min_db) * value) + min_db;\n    float gain_value = (powf(10,(db_value/20)) - powf(10,(min_db/20))) / (1 - powf(10, (min_db/20)));\n\n    return gain_value;\n}\n\nint MasterOut_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n \n    float l_gain, r_gain;\n    MasterOut* master_out = (MasterOut*)io->param_object;\n\n    int retval = IO_pull_sample(master_out->input, sample_l, sample_r, sample_g);\n        \n    //Gain\n    *sample_l *= db2gain(Slider_get_value(master_out->gain_slider));\n    *sample_r *= db2gain(Slider_get_value(master_out->gain_slider));\n\n    //Pan\n    r_gain = (1.0 - Slider_get_value(master_out->pan_slider))/2.0;\n    l_gain = (1.0 + Slider_get_value(master_out->pan_slider))/2.0;\n    (*sample_l) = (*sample_l) * l_gain;\n    (*sample_r) = (*sample_r) * r_gain;\n\n    //printf(\"%f/%f\\n\", l_gain, r_gain);\n\n    *sample_g = 1;\n\n    return retval;\n}\n\nvoid MasterOut_delete_function(Object* master_out_object) {\n\n    MasterOut* master_out = (MasterOut*)master_out_object;\n\n    //Need to do this since, because the output IO never gets installed \n    //as a child of the window, it won't be deleted by the window deleter\n    Object_delete((Object*)(Object*)master_out->output);\n    Unit_delete(master_out_object);\n}\n\nvoid MasterOut_paint_handler(Window* master_out_window) {\n\n    Frame_paint_handler(master_out_window);\n    Context_draw_text(master_out_window->context, \"Master Out\",\n                       (master_out_window->width / 2) - 40,\n                       (master_out_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* MasterOut_constructor(PatchCore* patch_core) {\n\n    MasterOut* master_out = (MasterOut*)malloc(sizeof(MasterOut));\n\n    if(!master_out)\n        return (Unit*)master_out;\n\n    if(!Unit_init((Unit*)master_out, patch_core)) {\n\n        Object_delete((Object*)master_out);\n        return (Unit*)0;\n    }\n\n    Object_init((Object*)master_out, MasterOut_delete_function);\n    master_out->gain_slider = Slider_new(10, 10, 30, 130, 0, 1);\n    master_out->pan_slider = Slider_new(50, 110, 140, 30, -1, 1);\n    master_out->input = Unit_create_input((Unit*)master_out, 5, 75);\n    master_out->output = IO_new(patch_core, (Object*)master_out, 0, 0, 1);\n\n    if(!(master_out->gain_slider && master_out->input\n       && master_out->output && master_out->pan_slider)) {\n\n        Object_delete((Object*)master_out);\n        return (Unit*)0;\n    }    \n\n    Window_insert_child((Window*)master_out, (Window*)master_out->pan_slider);\n    Window_insert_child((Window*)master_out, (Window*)master_out->gain_slider);\n    Window_resize((Window*)master_out, 200, 150);\n\n    master_out->output->pull_sample_function = MasterOut_pull_sample_handler;\n    master_out->unit.frame.window.paint_function = MasterOut_paint_handler;\n    PatchCore_add_source(patch_core, master_out->output);\n\n    return (Unit*)master_out;\n}\n","#include \"menu.h\"\n\nMenu* Menu_new(int x, int y, int width) {\n\n    Menu* menu;\n    if(!(menu = (Menu*)malloc(sizeof(Menu))))\n        return menu;\n\n    if(!Menu_init(menu, x, y, width)) {\n\n        free(menu);\n        return (Menu*)0;\n    }\n\n    return menu;\n}\n\nint Menu_init(Menu* menu, int x, int y, int width) {\n\n    return Frame_init((Frame*)menu, x, y, width, 4);\n}\n\nvoid Menu_add_entry(Menu* menu, MenuEntry* menu_entry) {\n\n    Window_insert_child((Window*)menu, (Window*)menu_entry);\n    menu_entry->window.width = menu->frame.window.width - 4;\n    menu_entry->window.x = 2;\n    menu_entry->window.y = ((menu->frame.window.children->count - 1) * 14) + 2;\n    menu->frame.window.height += 14;\n}\n","#include \"menuentry.h\"\n\nMenuEntry* MenuEntry_new(String* text, WindowMouseclickHandler click_action) {\n\n    MenuEntry* menu_entry;\n\n    if(!(menu_entry = (MenuEntry*)malloc(sizeof(MenuEntry))))\n        return menu_entry;\n\n    if(!(Window_init((Window*)menu_entry, 0, 0, 100, 14, WIN_NORAISE | WIN_NODECORATION, (Context*)0))) {\n\n        Object_delete((Object*)menu_entry);\n        return (MenuEntry*)0;\n    }\n\n    Object_init((Object*)menu_entry, MenuEntry_delete_function);\n\n    if(!(menu_entry->text = String_new(text->buf))) {\n\n        Object_delete((Object*)menu_entry);\n        return (MenuEntry*)0;\n    }\n\n    menu_entry->mouse_over = 0;\n    menu_entry->window.paint_function = MenuEntry_paint_handler;\n    menu_entry->window.mouseclick_function = click_action;\n    menu_entry->window.mouseover_function = MenuEntry_mouseover_handler;\n    menu_entry->window.mouseout_function = MenuEntry_mouseout_handler;\n\n    return menu_entry;\n}\n\nvoid MenuEntry_toggle_over(Window* menu_entry_window, int over) {\n\n    MenuEntry* menu_entry = (MenuEntry*)menu_entry_window;\n\n    menu_entry->mouse_over = over;\n    Window_invalidate(menu_entry_window, 0, 0, menu_entry_window->height - 1,\n                      menu_entry_window->width - 1);\n}\n\nvoid MenuEntry_mouseover_handler(Window* menu_entry_window) {\n\n    MenuEntry_toggle_over(menu_entry_window, 1);\n}\n\nvoid MenuEntry_mouseout_handler(Window* menu_entry_window) {\n\n    MenuEntry_toggle_over(menu_entry_window, 0);\n}\n\nvoid MenuEntry_paint_handler(Window* menu_entry_window) {\n\n    MenuEntry* menu_entry = (MenuEntry*)menu_entry_window;\n\n    //Current code assumes that the font is 12px high\n    Context_fill_rect(menu_entry_window->context, 0, 0, menu_entry_window->width,\n                      menu_entry_window->height,\n                      menu_entry->mouse_over ? RGB(0, 0, 0) : RGB(155, 165, 185));\n    Context_draw_text(menu_entry_window->context, menu_entry->text->buf,\n                      1, 1, menu_entry->mouse_over ? RGB(255, 255, 255) : RGB(0, 0, 0));\n}\n\nvoid MenuEntry_delete_function(Object* menu_entry_object) {\n\n    MenuEntry* menu_entry;\n\n    if(!menu_entry_object)\n        return;\n\n    menu_entry = (MenuEntry*)menu_entry_object;\n\n    Object_delete((Object*)menu_entry->text);\n    Window_delete_function(menu_entry_object);\n}\n","#include \"module.h\"\n#include <stdlib.h>\n\nModule* Module_new(ModuleConstructor constructor, char* name) {\n\n    Module* module;\n    if(!(module = (Module*)malloc(sizeof(Module))))\n        return module;\n\n    Object_init((Object*)module, Module_delete_function);    \n    module->constructor = constructor;\n    \n    if(!(module->name = String_new(name))) {\n\n        Object_delete((Object*)module);\n        return (Module*)0;\n    }\n\n    return module;\n}\n\nvoid Module_delete_function(Object* module_object) {\n\n    Module* module;\n\n    if(!module_object)\n        return;\n\n    module = (Module*)module_object;\n\n    Object_delete((Object*)module->name);\n    Object_default_delete_function(module_object);\n} \n","#include <stdio.h>\n#include <time.h>\n#include <stdlib.h>\n#include \"noise.h\"\n\nModule* Noise_new() {\n\n    return Module_new(Noise_constructor, \"Noise\");\n}\n\nfloat float_rand() {\n\n    time_t t;\n    float r;\n\n    r = (PlatformWrapper_random() - 0.5) * 2;\n\n    return r;\n}\n\nint Noise_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n\n    //Not really used here, but whatever\n    Noise* noise = (Noise*)io->param_object;\n\n    //Stereo noise\n    *sample_l = float_rand();\n    *sample_r = float_rand();\n    *sample_g = 1;\n\n    return 1;\n}\n\nvoid Noise_paint_handler(Window* noise_window) {\n\n    Frame_paint_handler(noise_window);\n    Context_draw_text(noise_window->context, \"Noise\",\n                       (noise_window->width / 2) - 20,\n                       (noise_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* Noise_constructor(PatchCore* patch_core) {\n\n    Noise* noise = (Noise*)malloc(sizeof(Noise));\n\n    if(!noise)\n        return (Unit*)noise;\n\n    if(!Unit_init((Unit*)noise, patch_core)) {\n\n        Object_delete((Object*)noise);\n        return (Unit*)0;\n    }\n\n    noise->output = Unit_create_output((Unit*)noise, 195, 75);\n    Window_resize((Window*)noise, 200, 150);\n\n    if(!(noise->output)) {\n\n        Object_delete((Object*)noise);\n        return (Unit*)0;\n    }    \n   \n    noise->output->pull_sample_function = Noise_pull_sample_handler;\n    noise->unit.frame.window.paint_function = Noise_paint_handler;\n\n    return (Unit*)noise;\n}","#include <stdlib.h>\n#include <string.h>\n#include \"object.h\"\n\nString* String_new(char* source_buf) {\n\n    int len, i;\n    String* string = (String*)malloc(sizeof(String));\n\n    if(!string)\n        return string;\n\n    Object_init((Object*)string, String_delete_function);\n    \n    if(!source_buf) {\n\n        string->buf = source_buf;\n        return string;\n    }\n\n    for(len = 1; source_buf[len-1]; len++);\n\n    if(!(string->buf = (char*)malloc(len))) {\n\n        Object_delete((Object*)string);\n        return (String*)0;\n    }\n\n    for(i = 0; i < len; i++)\n        string->buf[i] = source_buf[i];\n\n    return string;\n}\n\nint String_compare(String* string_a, String* string_b) {\n\n    return strcmp(string_a->buf, string_b->buf) == 0;\n}\n\nvoid String_delete_function(Object* string_object) {\n\n    String* string;\n\n    if(!string_object)\n        return;\n\n    string = (String*)string_object;\n\n    if(string->buf)\n        free(string->buf);\n\n    Object_default_delete_function(string_object);\n}\n\nvoid Object_default_delete_function(Object* object) {\n\n    free((void*)object);\n}\n\nvoid Object_init(Object* object, DeleteFunction delete_function) {\n\n    if(delete_function)\n        object->delete_function = delete_function;\n    else\n        object->delete_function = Object_default_delete_function;\n}\n\nvoid Object_delete(Object* object) {\n\n    if(!object)\n        return;\n\n    if(object->delete_function)\n        object->delete_function(object);\n    else\n        Object_default_delete_function(object);\n}\n","#include \"patchcore.h\"\n#include \"../units/masterout.h\"\n#include \"../units/noise.h\"\n#include \"../units/pitchknob.h\"\n#include \"../units/sequence.h\"\n#include \"../units/sine.h\"\n#include \"../units/square.h\"\n#include \"../units/vca.h\"\n#include \"../units/adsr.h\"\n#include \"../units/split.h\"\n#include \"../units/scope.h\"\n#include <stdlib.h>\n#include <stdio.h>\n\nPatchCore* PatchCore_new() {\n\n    PatchCore* patch;\n    if(!(patch = (PatchCore*)malloc(sizeof(PatchCore))))\n        return patch;\n\n    Object_init((Object*)patch, PatchCore_delete_function);\n    patch->modules = AssociativeArray_new();\n    patch->sources = List_new();\n    patch->desktop = (PatchDesktop*)0;\n    patch->inputs = List_new();\n    patch->outputs = List_new();\n\n    if(!(patch->modules && patch->sources && patch->inputs)) {\n\n        Object_delete((Object*)patch);\n        return (PatchCore*)0;\n    }\n\n    return patch;\n}\n\nint PatchCore_install_module(PatchCore* patch, Module* module) {\n\n    return AssociativeArray_add(patch->modules, module->name, (Object*)module);\n}\n\nint PatchCore_next_spawn_x(PatchCore* patch) {\n\n    return 0;\n}\n\nint PatchCore_next_spawn_y(PatchCore* patch) {\n\n    return 0;\n}\n\nvoid Patch_mouse_callback(Object* desktop_object, uint16_t mouse_x,\n                           uint16_t mouse_y, uint8_t mouse_buttons) {\n\n    Desktop_process_mouse((Desktop*)desktop_object, mouse_x, mouse_y, mouse_buttons);\n}\n\nvoid Patch_resize_callback(Object* desktop_object, int w, int h) {\n\n    //Make sure that any changes to the root context get carried to all windows\n    Window_update_context((Window*)desktop_object, ((PatchDesktop*)desktop_object)->base_context);\n    Window_resize((Window*)desktop_object, w, h);\n}\n\nvoid PatchCore_start(PatchCore* patch) {\n\n    //TODO: This will be replaced by the loading of default modules from a list\n    printf(\"Installing MasterOut...\");\n    PatchCore_install_module(patch, MasterOut_new());\n    printf(\"Done\\nInstalling Noise...\");\n    PatchCore_install_module(patch, Noise_new());\n    printf(\"Done\\nInstalling Sine...\");\n    PatchCore_install_module(patch, Sine_new());\n    printf(\"Done\\nInstalling PitchKnob...\");\n    PatchCore_install_module(patch, PitchKnob_new());\n    printf(\"Done\\nInstalling Sequence...\");\n    PatchCore_install_module(patch, Sequence_new());\n    printf(\"Done\\nInstalling Square...\");\n    PatchCore_install_module(patch, Square_new());\n    printf(\"Done\\nInstalling VCA...\");\n    PatchCore_install_module(patch, VCA_new());\n    printf(\"Done\\nInstalling ADSR...\");\n    PatchCore_install_module(patch, ADSR_new());\n    printf(\"Done\\nInstalling Split...\");\n    PatchCore_install_module(patch, Split_new());\n    printf(\"Done\\nInstalling Scope...\");\n    PatchCore_install_module(patch, Scope_new());\n    printf(\"Done\\n\");\n\n    printf(\"Creating PatchDesktop...\");\n    patch->desktop = PatchDesktop_new(patch);\n    PlatformWrapper_install_resize_callback((Object*)patch->desktop, Patch_resize_callback);\n    PlatformWrapper_install_mouse_callback((Object*)patch->desktop, Patch_mouse_callback);\n    \n    printf(\"Done\\nPerforming initial paint...\");\n    Window_paint((Window*)patch->desktop, (List*)0, 1);\n\n    printf(\"Done\\nInstalling audio handler...\");\n    PlatformWrapper_install_audio_handler(AudioHandler_new(PatchCore_pull_sample, (Object*)patch));\n    printf(\"Done\\n\");\n}\n\n\nint PatchCore_add_source(PatchCore* patch, IO* source) {\n\n    if(!source->is_output)\n        return 0;\n\n    return List_add(patch->sources, (Object*)source);\n}\n\nvoid PatchCore_remove_source(PatchCore* patch, IO* source) {\n\n    int i;\n\n    for(i = 0; i < patch->sources->count; i++)\n        if(List_get_at(patch->sources, i) == (Object*)source)\n            break;\n\n    if(i == patch->sources->count)\n        return;\n\n    List_remove_at(patch->sources, i);\n}\n\nList* PatchCore_get_module_list(PatchCore* patch) {\n\n    return patch->modules->keys;\n}\n\nvoid PatchCore_connect_action(PatchCore* patch, IO* io) {\n\n    PatchDesktop_connect_action(patch->desktop, io);\n}\n\nvoid PatchCore_destroy_menu(PatchCore* patch) {\n    \n    Object_delete((Object*)patch->desktop->menu);\n    patch->desktop->menu = (SessionMenu*)0;\n}\n\nvoid PatchCore_instantiate_module(PatchCore* patch, String* module_name) {\n\n    Module* module;\n    Window* window;\n\n    module = (Module*)AssociativeArray_get(patch->modules, module_name);\n    if(!module)\n        return;\n\n    window = (Window*)module->constructor(patch);\n    if(!window)\n        return;\n\n    Window_insert_child((Window*)patch->desktop, window);\n    Window_move(window, PatchCore_next_spawn_x(patch), PatchCore_next_spawn_y(patch));\n}\n\nvoid PatchCore_pull_sample(Object* patch_object, float* sample_l, float* sample_r) {\n\n    int i;\n    IO* source;\n    float temp_l, temp_r, temp_g;\n    PatchCore* patch = (PatchCore*)patch_object;\n\n    *sample_r = 0;\n    *sample_l = 0;\n\n    //Render all outputs\n    for(i = 0; i < patch->outputs->count; i++)\n        IO_render_sample((IO*)List_get_at(patch->outputs, i));\n\n    //Latch all of the new output values into all inputs\n    for(i = 0; i < patch->inputs->count; i++)\n        IO_update_latches((IO*)List_get_at(patch->inputs, i));\n\n    //Sum the value of all outputs registered as 'sources'\n    for(i = 0; i < patch->sources->count; i++) {\n\n        source = (IO*)List_get_at(patch->sources, i);\n        \n        IO_pull_sample(source, &temp_l, &temp_r, &temp_g);\n        *sample_r += temp_r;\n        *sample_l += temp_l;\n    }\n}\n\nvoid PatchCore_delete_function(Object* patch_object) {\n    \n    PatchCore* patch = (PatchCore*)patch_object;\n\n    Object_delete((Object*)patch->modules);\n\n    //Empty sources list before deleting\n    //(These are a subset of window-owned outputs,\n    //they will automatically be deleted when the\n    //desktop is deleted)\n    while(patch->sources->count)\n        List_remove_at(patch->sources, 0);\n\n    Object_delete((Object*)patch->sources);\n\n    //Do the same for the outputs collection\n    while(patch->outputs->count)\n        List_remove_at(patch->outputs, 0);\n    \n    Object_delete((Object*)patch->outputs);\n    \n    //And for the input collection\n    while(patch->inputs->count)\n        List_remove_at(patch->inputs, 0);\n    \n    Object_delete((Object*)patch->inputs);\n\n    Object_delete((Object*)patch->desktop);\n    Object_default_delete_function(patch_object);\n}\n","#include \"patchdesktop.h\"\n\nPatchDesktop* PatchDesktop_new(PatchCore* patch_core) {\n\n    PatchDesktop* patch_desktop = (PatchDesktop*)malloc(sizeof(PatchDesktop));\n    \n    if(!patch_desktop)\n        return patch_desktop;\n\n    if(!(patch_desktop->base_context = PlatformWrapper_get_context())) {\n\n        Object_delete((Object*)patch_desktop);\n        return (PatchDesktop*)0;\n    }\n\n    if(!Desktop_init((Desktop*)patch_desktop, patch_desktop->base_context)) {\n    \n        Object_delete((Object*)patch_desktop->base_context);\n        Object_delete((Object*)patch_desktop);\n        return (PatchDesktop*)0;\n    }\n\n    Object_init((Object*)patch_desktop, PatchDesktop_delete_function);\n\n    patch_desktop->patch_core = patch_core;\n    patch_desktop->desktop.window.mouseclick_function = PatchDesktop_mouseclick_handler;\n    patch_desktop->desktop.window.mousemove_function = PatchDesktop_mousemove_handler;\n    patch_desktop->desktop.window.paint_function = PatchDesktop_paint_handler;\n    patch_desktop->desktop.mouse_shown = PlatformWrapper_is_mouse_shown();\n    patch_desktop->start_io = (IO*)0;\n    patch_desktop->menu = (SessionMenu*)0;\n\n    return patch_desktop;\n}\n\nvoid PatchDesktop_mouseclick_handler(Window* patch_desktop_window, int x, int y) {\n\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\n\n    if(patch_desktop->start_io)\n        PatchDesktop_end_connection(patch_desktop);\n\n    if(patch_desktop->menu) {\n\n        Object_delete((Object*)patch_desktop->menu);\n        patch_desktop->menu = (SessionMenu*)0;\n    } else {\n\n        patch_desktop->menu = SessionMenu_new(patch_desktop->patch_core, x, y);\n        Window_insert_child((Window*)patch_desktop, (Window*)patch_desktop->menu);\n    }\n}\n\nvoid draw_elbow(Context* context, int x1, int y1, int x2, int y2, uint32_t color) {\n\n    int hlen = x2 - x1;\n    int temp, vlen;\n\n    if(hlen < 0) {\n\n        temp = x1;\n        x1 = x2;\n        x2 = temp;\n        temp = y1;\n        y1 = y2;\n        y2 = temp;\n        hlen = -hlen;\n    }\n\n    Context_horizontal_line(context, x1, y1, hlen/2, color);\n    Context_horizontal_line(context, x1 + (hlen/2), y2, hlen/2, color);\n\n    vlen = y2 - y1;\n\n    if(vlen < 0) {\n\n        y1 = y2;\n        vlen = -vlen;\n    }\n\n    Context_vertical_line(context, x1 + (hlen/2), y1, vlen, color);\n}\n\nvoid PatchDesktop_paint_handler(Window* patch_desktop_window) {\n\n    int i;\n    IO* input;\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\n\n    Context_fill_rect(patch_desktop_window->context, 0, 0, patch_desktop_window->width,\n                      patch_desktop_window->height, RGB(90, 95, 210));\n\n    //Need an int to string function here (steal from calc)\n    Context_draw_text(patch_desktop_window->context, \"PATCH Build Number ?\",\n                      5, patch_desktop_window->height - 18, RGB(255, 255, 255));\n\n    if(patch_desktop->start_io) {\n\n        //TODO: really should implement clipped bresenham\n        draw_elbow(patch_desktop_window->context, Window_screen_x((Window*)patch_desktop->start_io) + 3,\n                   Window_screen_y((Window*)patch_desktop->start_io) + 3, patch_desktop->wire_x, \n                   patch_desktop->wire_y, RGB(200, 0, 0));\n    }\n\n    for(i = 0; i < patch_desktop->patch_core->inputs->count; i++) {\n\n        input = (IO*)List_get_at(patch_desktop->patch_core->inputs, i);\n\n        if(input->connected_io) {\n\n            draw_elbow(patch_desktop_window->context, Window_screen_x((Window*)input) + 2,\n                   Window_screen_y((Window*)input) + 2, Window_screen_x((Window*)input->connected_io) + 2, \n                   Window_screen_y((Window*)input->connected_io) + 2, RGB(0, 200, 0));\n        }\n    }\n}\n\nvoid PatchDesktop_connect_action(PatchDesktop* patch_desktop, IO* io) {\n\n    if(patch_desktop->start_io)\n        PatchDesktop_finish_connection(patch_desktop, io);\n    else\n        PatchDesktop_begin_connection(patch_desktop, io);\n}\n\nvoid PatchDesktop_begin_connection(PatchDesktop* patch_desktop, IO* io) {\n\n    patch_desktop->start_io = io;\n\n    Window_invalidate((Window*)io, 0, 0, io->window.height - 1, io->window.width - 1);\n}\n\nvoid PatchDesktop_finish_connection(PatchDesktop* patch_desktop, IO* io) {\n\n    if(patch_desktop->start_io) {\n\n        //Guard against input-to-input and output-to-output\n        if((!!patch_desktop->start_io->is_output) == (!!io->is_output))\n            return;\n\n        IO_connect(patch_desktop->start_io, io);\n        IO_connect(io, patch_desktop->start_io);\n        Window_invalidate((Window*)patch_desktop->start_io, 0, 0,\n                          patch_desktop->start_io->window.height - 1,\n                          patch_desktop->start_io->window.width - 1);\n        Window_invalidate((Window*)io, 0, 0, io->window.height - 1, io->window.width - 1);\n        patch_desktop->start_io = (IO*)0;\n        Window_invalidate((Window*)patch_desktop, 0, 0, patch_desktop->desktop.window.width - 1,\n                          patch_desktop->desktop.window.height - 1);\n    }\n}\n\nvoid PatchDesktop_end_connection(PatchDesktop* patch_desktop) {\n\n    patch_desktop->start_io = (IO*)0;\n    Window_invalidate((Window*)patch_desktop, 0, 0, patch_desktop->desktop.window.width - 1,\n                      patch_desktop->desktop.window.height - 1);\n}\n\nvoid PatchDesktop_mousemove_handler(Window* patch_desktop_window, int x, int y) {\n\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\n\n    if(!patch_desktop->start_io)\n        return;\n\n    patch_desktop->wire_x = x;\n    patch_desktop->wire_y = y;\n    Window_invalidate((Window*)patch_desktop, 0, 0, patch_desktop->desktop.window.width - 1,\n                      patch_desktop->desktop.window.height - 1);\n}\n\nvoid PatchDesktop_delete_function(Object* patch_desktop_object) {\n\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_object;\n\n    if(!patch_desktop_object)\n        return;\n\n    Object_delete((Object*)patch_desktop->menu);\n    Window_delete_function(patch_desktop_object);\n}","#include <math.h>\n#include \"pitchknob.h\"\n\nModule* PitchKnob_new() {\n\n    return Module_new(PitchKnob_constructor, \"Pitch Knob\");\n}\n\nint PitchKnob_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n\n    PitchKnob* pitch_knob = (PitchKnob*)io->param_object;\n\n    *sample_l = *sample_r =\n        2*(powf(2, ((1 - Slider_get_value(pitch_knob->slider)) * 6))); \n    *sample_g = 1;\n\n    return 1;\n}\n\nUnit* PitchKnob_constructor(PatchCore* patch_core) {\n\n    PitchKnob* pitch_knob = (PitchKnob*)malloc(sizeof(PitchKnob));\n\n    if(!pitch_knob)\n        return (Unit*)pitch_knob;\n\n    if(!Unit_init((Unit*)pitch_knob, patch_core)) {\n\n        Object_delete((Object*)pitch_knob);\n        return (Unit*)0;\n    }\n\n    pitch_knob->slider = Slider_new(10, 10, 30, 130, 0, 1);\n\n    if(pitch_knob->slider)\n        Window_insert_child((Window*)pitch_knob, (Window*)pitch_knob->slider);\n\n    pitch_knob->output = Unit_create_output((Unit*)pitch_knob, 45, 75);\n\n    if(!(pitch_knob->slider && pitch_knob->output)) {\n\n        Object_delete((Object*)pitch_knob);\n        return (Unit*)0;\n    }    \n\n    Window_resize((Window*)pitch_knob, 50, 150);\n    pitch_knob->output->pull_sample_function = PitchKnob_pull_sample_handler;\n\n    return (Unit*)pitch_knob;\n}","#include \"platformwrapper.h\"\n#include <emscripten.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"../wslib/list.h\"\n\nMouseCallback mouse_handler;\nResizeCallback resize_handler;\nContext* internal_context;\nfloat left_sum, right_sum;\nList* ah_list;\n\nvoid EMSCRIPTEN_KEEPALIVE doPullSample() {\n\n    int i;\n    float l, r;\n    AudioHandler* ah;\n\n    EM_ASM(\n        window.fo_sample[0] = window.fo_sample[1] = 0;\n    );\n\n    for(i = 0; i < ah_list->count; i++) {\n\n        ah = (AudioHandler*)List_get_at(ah_list, i);\n        ah->function(ah->parent_object, &l, &r);\n\n        EM_ASM_({\n            window.fo_sample[0] += $0;\n            window.fo_sample[1] += $1;\n        }, l, r);\n    }\n}\n\nvoid PlatformWrapper_init() {\n\n    ah_list = List_new();\n    internal_context = (Context*)0;\n    mouse_handler.param_object = (Object*)0;\n    mouse_handler.callback = (MouseCallback_handler)0;\n    resize_handler.param_object = (Object*)0;\n    resize_handler.callback = (ResizeCallback_handler)0;\n\n    //Set up the audio processing loop\n    EM_ASM(\n\n        window.fo_sample = [0, 0];\n\n        var audioCtx  = new (window.AudioContext || window.webkitAudioContext)(),\n            pcm_node  = audioCtx.createScriptProcessor(4096, 0, 2),\n            source    = audioCtx.createBufferSource();\n\n        pcm_node.onaudioprocess = function(e) {\n\n            var outbuf_l = e.outputBuffer.getChannelData(0),\n                outbuf_r = e.outputBuffer.getChannelData(1);\n    \n            for(var i = 0; i < 4096; i++) {\n                \n                Module.ccall('doPullSample');\n                outbuf_r[i] = window.fo_sample[1];\n                outbuf_l[i] = window.fo_sample[0];\n            }\n\n            if(window.dbg_on)\n                    debugger;\n        };\n\n        source.connect(pcm_node);\n        pcm_node.connect(audioCtx.destination);\n        source.start();\n    );\n}\n\nvoid PlatformWrapper_hold_for_exit() {\n\n    return; //Emscripten doesn't like hang loops\n}\n\nvoid PlatformWrapper_install_audio_handler(AudioHandler* audio_handler) {\n\n    List_add(ah_list, (Object*)audio_handler);\n}\n\nint PlatformWrapper_is_mouse_shown() {\n\n    //Emscripten just uses the OS mouse\n    return 0;\n}\n\nContext* PlatformWrapper_get_context() {\n\n    //Init the display\n    //Declare our return variable\n    uint32_t *return_buffer = (uint32_t*)0;\n\n    //Clear the dimensions until we've gotten past any potential errors\n    uint16_t width = EM_ASM_INT({return window.innerWidth},0);\n    uint16_t height = EM_ASM_INT({return window.innerHeight},0);\n\n    //Attempt to create the framebuffer array \n    if(!(return_buffer = (uint32_t*)malloc(sizeof(uint32_t) * width * height)))\n        return (Context*)0; //Exit early indicating error with an empty pointer \n\n    //Clear the framebuffer to black\n    int i;\n    for(i = 0; i < width * height; i++)\n        return_buffer[i] = 0xFF000000; //The canvas *does* care about the opacity being set, which is annoying\n    \n    //Now we'll create the output canvas and insert it into the document\n    //(EM_ASM allows us to embed JS into our C)\n    //We will also se up the refresh timer here\n    EM_ASM_({ \n        \n        //Create and store canvas and information\n        window.fo_canvas = document.createElement('canvas');\n        document.body.style.margin = '0px';\n        window.fo_canvas.width = $0;\n        window.fo_canvas.height = $1;\n        window.fo_buf_address = $2;\n        window.fo_buf_size = 4 * $0 * $1;\n        document.body.appendChild(window.fo_canvas);\n        window.fo_context = window.fo_canvas.getContext('2d');\n        window.fo_canvas_data = window.fo_context.getImageData(0, 0, $0, $1);\n        window.fo_draw = true;\n\n        //Start refresh handler\n        setInterval(function() {\n\n            if(!window.fo_draw)\n                return;\n\n            //Create an unsigned byte subarray  \n            window.fo_canvas_data.data.set(\n                Module.HEAPU8.subarray(\n                    window.fo_buf_address, window.fo_buf_address + window.fo_buf_size\n                )\n            ); \n            window.fo_context.putImageData(window.fo_canvas_data, 0, 0);\n            \n        }, 17);\n    }, width, height, return_buffer);\n\n    internal_context = Context_new(width, height, return_buffer);\n\n    return internal_context;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE doMouseCallback(void) {\n\n    uint16_t mouse_x, mouse_y;\n    uint8_t buttons;\n\n    if(!mouse_handler.callback)\n        return;\n\n    //A mouse event has happened, so get the updated info \n    mouse_x = EM_ASM_INT({\n        return window.fo_mouse_x;\n    }, 0);\n\n    mouse_y = EM_ASM_INT({\n        return window.fo_mouse_y;\n    }, 0);\n\n    buttons = EM_ASM_INT({\n        return window.fo_button_status;\n    }, 0);\n\n    //Fire callback\n    mouse_handler.callback(mouse_handler.param_object, mouse_x, mouse_y, buttons);\n}\n\nvoid PlatformWrapper_install_mouse_callback(Object* param_object, MouseCallback_handler callback) {\n\n    //This is literally just here so that the function \n    //doesn't get optimized out\n    doMouseCallback();\n\n    EM_ASM(\n\n        //Attach status update function to the screen canvas\n        window.fo_button_status = 0;\n        window.fo_mouse_x = 0;\n        window.fo_mouse_y = 0;\n        window.fo_canvas.onmousemove = function(e) {\n            \n            window.fo_mouse_x = e.clientX;\n            window.fo_mouse_y = e.clientY;\n            Module.ccall('doMouseCallback');\n        };\n        window.fo_canvas.onmousedown = function(e) {\n\n            window.fo_button_status = 1;\n            Module.ccall('doMouseCallback');\n        };\n        window.fo_canvas.onmouseup = function(e) {\n\n            window.fo_button_status = 0;\n            Module.ccall('doMouseCallback');\n        };\n    );\n\n    mouse_handler.param_object = param_object;\n    mouse_handler.callback = callback;\n}\n\nvoid EMSCRIPTEN_KEEPALIVE doResizeCallback() {\n\n    uint16_t width = EM_ASM_INT({return window.innerWidth},0);\n    uint16_t height = EM_ASM_INT({return window.innerHeight},0);\n\n    free(internal_context->buffer);\n    internal_context->buffer = (uint32_t*)malloc(sizeof(uint32_t) * width * height);\n    internal_context->width = width;\n    internal_context->height = height;\n\n    EM_ASM_({\n        window.fo_buf_address = $0;\n        window.fo_buf_size = 4 * window.fo_canvas.width * window.fo_canvas.height;\n        window.fo_canvas_data = window.fo_context.getImageData(0, 0, window.fo_canvas.width, window.fo_canvas.height);\n        window.fo_draw = true;\n    }, internal_context->buffer);\n\n    resize_handler.callback(resize_handler.param_object, width, height);\n}\n\nvoid PlatformWrapper_install_resize_callback(Object* param_object, ResizeCallback_handler callback) {\n\n    EM_ASM(\n    \n        window.onresize = function() {\n\n            window.fo_draw = false;\n            window.fo_canvas.width = window.innerWidth;\n            window.fo_canvas.height = window.innerHeight;\n            Module.ccall('doResizeCallback');\n        };\n    );\n\n    resize_handler.param_object = param_object;\n    resize_handler.callback = callback;\n}\n\nfloat PlatformWrapper_random() {\n\n    return EM_ASM_DOUBLE({ return Math.random(); }, 0);\n}\n","#include \"rect.h\"\n\n//================| Rect Class Implementation |================//\n\n//Allocate a new rectangle object\nRect* Rect_new(int top, int left, int bottom, int right) {\n\n    //Attempt to allocate the object\n    Rect* rect;\n    if(!(rect = (Rect*)malloc(sizeof(Rect))))\n        return rect;\n\n    //Assign intial values\n    Object_init((Object*)rect, 0);\n    rect->top = top;\n    rect->left = left;\n    rect->bottom = bottom;\n    rect->right = right;\n\n    return rect;\n}\n\n//Explode subject_rect into a list of contiguous rects which are\n//not occluded by cutting_rect\n// ________                ____ ___\n//|s    ___|____          |o   |o__|\n//|____|___|   c|   --->  |____|          \n//     |________|              \nList* Rect_split(Rect* subject_rect, Rect* cutting_rect) {\n\n    //Allocate the list of result rectangles\n    Rect subject_copy;\n    List* output_rects;\n    \n    //We need a rectangle to hold new rectangles before\n    //they get pushed into the output list\n    Rect* temp_rect;\n    \n    if(!(output_rects = List_new()))\n        return output_rects;\n\n    //We're going to modify the subject rect as we go,\n    //so we'll clone it so as to not upset the object \n    //we were passed\n    subject_copy.top = subject_rect->top;\n    subject_copy.left = subject_rect->left;\n    subject_copy.bottom = subject_rect->bottom;\n    subject_copy.right = subject_rect->right;\n\n    //Begin splitting\n    //1 -Split by left edge if that edge is between the subject's left and right edges \n    if(cutting_rect->left > subject_copy.left && cutting_rect->left <= subject_copy.right) {\n\n        //Try to make a new rectangle spanning from the subject rectangle's left and stopping before \n        //the cutting rectangle's left\n        if(!(temp_rect = Rect_new(subject_copy.top, subject_copy.left,\n                                  subject_copy.bottom, cutting_rect->left - 1))) {\n\n            //If the object creation failed, we need to delete the list and exit failed\n            free(output_rects);\n\n            return (List*)0;\n        }\n\n        //Add the new rectangle to the output list\n        List_add(output_rects, (Object*)temp_rect);\n\n        //Shrink the subject rectangle to exclude the split portion\n        subject_copy.left = cutting_rect->left;\n    }\n\n    //2 -Split by top edge if that edge is between the subject's top and bottom edges \n    if(cutting_rect->top > subject_copy.top && cutting_rect->top <= subject_copy.bottom) {\n\n        //Try to make a new rectangle spanning from the subject rectangle's top and stopping before \n        //the cutting rectangle's top\n        if(!(temp_rect = Rect_new(subject_copy.top, subject_copy.left,\n                                  cutting_rect->top - 1, subject_copy.right))) {\n\n            //If the object creation failed, we need to delete the list and exit failed\n            //This time, also delete any previously allocated rectangles\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\n                free(temp_rect);\n\n            free(output_rects);\n\n            return (List*)0;\n        }\n\n        //Add the new rectangle to the output list\n        List_add(output_rects, (Object*)temp_rect);\n\n        //Shrink the subject rectangle to exclude the split portion\n        subject_copy.top = cutting_rect->top;\n    }\n\n    //3 -Split by right edge if that edge is between the subject's left and right edges \n    if(cutting_rect->right >= subject_copy.left && cutting_rect->right < subject_copy.right) {\n\n        //Try to make a new rectangle spanning from the subject rectangle's right and stopping before \n        //the cutting rectangle's right\n        if(!(temp_rect = Rect_new(subject_copy.top, cutting_rect->right + 1,\n                                  subject_copy.bottom, subject_copy.right))) {\n\n            //Free on fail\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\n                free(temp_rect);\n\n            free(output_rects);\n\n            return (List*)0;\n        }\n\n        //Add the new rectangle to the output list\n        List_add(output_rects, (Object*)temp_rect);\n\n        //Shrink the subject rectangle to exclude the split portion\n        subject_copy.right = cutting_rect->right;\n    }\n\n    //4 -Split by bottom edge if that edge is between the subject's top and bottom edges \n    if(cutting_rect->bottom >= subject_copy.top && cutting_rect->bottom < subject_copy.bottom) {\n\n        //Try to make a new rectangle spanning from the subject rectangle's bottom and stopping before \n        //the cutting rectangle's bottom\n        if(!(temp_rect = Rect_new(cutting_rect->bottom + 1, subject_copy.left,\n                                  subject_copy.bottom, subject_copy.right))) {\n\n            //Free on fail\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\n                free(temp_rect);\n\n            free(output_rects);\n\n            return (List*)0;\n        }\n\n        //Add the new rectangle to the output list\n        List_add(output_rects, (Object*)temp_rect);\n\n        //Shrink the subject rectangle to exclude the split portion\n        subject_copy.bottom = cutting_rect->bottom;\n    }\n \n    //Finally, after all that, we can return the output rectangles \n    return output_rects;\n}\n\nRect* Rect_intersect(Rect* rect_a, Rect* rect_b) {\n\n    Rect* result_rect;\n\n    if(!(rect_a->left <= rect_b->right &&\n\t   rect_a->right >= rect_b->left &&\n\t   rect_a->top <= rect_b->bottom &&\n\t   rect_a->bottom >= rect_b->top))\n        return (Rect*)0;\n\n    if(!(result_rect = Rect_new(rect_a->top, rect_a->left,\n                                rect_a->bottom, rect_a->right)))\n        return (Rect*)0;\n\n    if(rect_b->left > result_rect->left && rect_b->left <= result_rect->right) \n        result_rect->left = rect_b->left;\n \n    if(rect_b->top > result_rect->top && rect_b->top <= result_rect->bottom) \n        result_rect->top = rect_b->top;\n\n    if(rect_b->right >= result_rect->left && rect_b->right < result_rect->right)\n        result_rect->right = rect_b->right;\n\n    if(rect_b->bottom >= result_rect->top && rect_b->bottom < result_rect->bottom)\n        result_rect->bottom = rect_b->bottom;\n\n    return result_rect;\n}\n","#include \"scope.h\"\n\n/*\ntypedef struct Scope_struct {\n    Unit unit;\n    Button* start_button;\n    Button* stop_button;\n    Button* zoom_in_button;\n    Button* zoom_out_button;\n    Button* scroll_left_button;\n    Button* scroll_right_button;\n    IO* input;\n    int capture_pointer;\n    float* sample_buf;\n} Scope;\n*/\n\nvoid* Scope_paint_handler(Window* scope_window) {\n\n    Frame_paint_handler((Frame*)scope_window);\n    Context_fill_rect(scope_window->context, 13, 13, 346, 246, RGB(255, 255, 255));\n    Context_fill_rect(scope_window->context, 12, 12, 348, 248, RGB(0, 0, 0));                  \n}\n\nModule* Scope_new() {\n\n    return Module_new(Scope_constructor, \"Scope\");\n}\n\nUnit* Scope_constructor(PatchCore* patch_core) {\n\n    Scope* scope;\n\n    scope = (Scope*)malloc(sizeof(Scope));\n\n    if(!scope)\n        return (Unit*)0;\n\n    Unit_init((Unit*)scope, patch_core);\n    Window_resize((Window*)scope, 400, 300);\n\n    scope->unit.frame.window.paint_function = Scope_paint_handler;\n\n    return (Unit*)scope;\n}\n","#include \"sequence.h\"\n\nModule* Sequence_new() {\n\n    return Module_new(Sequence_constructor, \"Sequence\");\n}\n\nint Sequence_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n\n    Sequence* sequence = (Sequence*)io->param_object;\n    int stepped = 0;\n\n    int i;\n    float current_clock_sample_l,\n           current_clock_sample_r,\n           in_sample_g,\n           step_sample_l[8],\n           step_sample_r[8];\n\n    if(!IO_pull_sample(sequence->clock_in, &current_clock_sample_l, &current_clock_sample_r, &in_sample_g))\n        return 0;\n\n    if(current_clock_sample_l > 0 && sequence->last_clock_sample <= 0) {\n\n        stepped = 1;\n        sequence->current_step++;\n    }\n\n    sequence->last_clock_sample = current_clock_sample_l;\n\n    if(sequence->current_step == 8)\n        sequence->current_step = 0;\n\n    for(i = 0; i < 8; i++) {\n\n        if(!IO_pull_sample((IO*)List_get_at(sequence->step_list, i), \n                           &step_sample_l[i], &step_sample_r[i], &in_sample_g))\n            return 0;\n    }\n\n    *sample_l = step_sample_l[sequence->current_step];\n    *sample_r = step_sample_r[sequence->current_step];\n    *sample_g = stepped ? -1.0 : 1.0;\n\n    if(stepped)\n        Window_invalidate((Window*)sequence, 30, 17, 40, 186);\n\n    return 1;\n}\n\nvoid Sequence_delete_function(Object* sequence_object) {\n\n    Sequence* sequence = (Sequence*)sequence_object;\n\n    //Clear the list so that the elements don't get freed on list\n    //deletion and then float-freed on window deletion\n    while(sequence->step_list && sequence->step_list->count)\n        List_remove_at(sequence->step_list, 0);\n\n    //Delete the emptied step list\n    Object_delete((Object*)sequence->step_list);\n    Unit_delete(sequence_object);\n}\n\nvoid Sequence_paint_handler(Window* sequence_window) {\n\n    int i;\n    Sequence* sequence = (Sequence*)sequence_window;\n\n    Frame_paint_handler(sequence_window);\n\n    for(i = 0; i < 8; i++) {\n\n        if(i == sequence->current_step)\n            Context_fill_rect(sequence_window->context, 20*(i+1) - 3, 30, 10, 10, RGB(255, 90, 90));\n        else\n            Context_fill_rect(sequence_window->context, 20*(i+1) - 3, 30, 10, 10, RGB(100, 50, 50));\n    }\n\n    Context_draw_text(sequence_window->context, \"Sequence\",\n                       (sequence_window->width / 2) - 32,\n                       (sequence_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* Sequence_constructor(PatchCore* patch_core) {\n\n    int i;\n    IO* temp_input;\n    Sequence* sequence = (Sequence*)malloc(sizeof(Sequence));\n\n    if(!sequence)\n        return (Unit*)sequence;\n\n    if(!Unit_init((Unit*)sequence, patch_core)) {\n\n        Object_delete((Object*)sequence);\n        return (Unit*)0;\n    }\n\n    Object_init((Object*)sequence, Sequence_delete_function);\n\n    sequence->step_list = List_new();\n\n    if(!sequence->step_list) {\n\n        Object_delete((Object*)sequence);\n        return (Unit*)0;\n    }    \n\n    \n    for(i = 0; i < 8; i++) {\n\n        temp_input = Unit_create_input((Unit*)sequence, 20*(i+1), 5);\n\n        if(!temp_input) {\n\n            Object_delete((Object*)sequence);\n            return (Unit*)0;\n        }    \n\n        List_add(sequence->step_list, (Object*)temp_input);\n    }\n\n    sequence->output = Unit_create_output((Unit*)sequence, 195, 75);\n    sequence->clock_in = Unit_create_input((Unit*)sequence, 5, 75);\n\n    if(!(sequence->clock_in && sequence->output)) {\n\n        Object_delete((Object*)sequence);\n        return (Unit*)0;\n    }    \n\n    Window_resize((Window*)sequence, 200, 150);\n    sequence->output->pull_sample_function = Sequence_pull_sample_handler;\n    sequence->current_step = 0;\n    sequence->last_clock_sample = 0;\n    sequence->unit.frame.window.paint_function = Sequence_paint_handler;\n\n    return (Unit*)sequence;\n}","\n#include \"sessionmenu.h\"\n\nSessionMenu* SessionMenu_new(PatchCore* patch_core, int x, int y) {\n\n    int i;\n    SessionMenu* session_menu = (SessionMenu*)malloc(sizeof(SessionMenu));\n\n    if(!session_menu)\n        return session_menu;\n\n    if(!Menu_init((Menu*)session_menu, x, y, 200)) {\n\n        Object_delete((Object*)session_menu);\n        return (SessionMenu*)0;\n    }\n\n    session_menu->patch_core = patch_core;\n    session_menu->module_names = PatchCore_get_module_list(patch_core);\n\n    //TODO: Need to add a sanity check in the case that the new menu entry\n    //couldn't be properly instantiated\n    for(i = 0; session_menu->module_names && (i < session_menu->module_names->count); i++)\n        Menu_add_entry((Menu*)session_menu,\n                       MenuEntry_new((String*)List_get_at(session_menu->module_names, i), SessionMenu_mouseclick_function));\n\n    return session_menu;\n}\n\nvoid SessionMenu_mouseclick_function(Window* session_menu_entry_window, int x, int y) {\n\n    MenuEntry* menu_entry;\n    SessionMenu* session_menu;\n\n    if(!session_menu_entry_window->parent)\n        return;\n\n    menu_entry = (MenuEntry*)session_menu_entry_window;\n    session_menu = (SessionMenu*)session_menu_entry_window->parent;\n\n    PatchCore_instantiate_module(session_menu->patch_core, menu_entry->text);\n    PatchCore_destroy_menu(session_menu->patch_core);\n}\n","#include <math.h>\n#include \"sine.h\"\n#include \"../platform/platformwrapper.h\"\n\nModule* Sine_new() {\n\n    return Module_new(Sine_constructor, \"Sine\");\n}\n\nint Sine_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n    \n    float in_sample_l, in_sample_r, in_sample_g;\n    Sine* sine = (Sine*)io->param_object;\n\n    if(!IO_pull_sample(sine->freq_in, &in_sample_l, &in_sample_r, &in_sample_g))\n        return 0;\n\n    if(in_sample_l == 0) {\n\n        *sample_l = *sample_r = 0;\n        return 1;\n    }\n\n    *sample_l = sinf(sine->phase);\n    *sample_r = sinf(sine->phase);\n    sine->phase = (sine->phase + (((2*M_PI) * in_sample_l)/SAMPLE_RATE));\n\n    if(sine->phase > (2*M_PI))\n        sine->phase -= (2*M_PI);\n\n    *sample_g = 1;\n\n    return 1;\n}\n\nvoid Sine_paint_handler(Window* sine_window) {\n\n    Frame_paint_handler(sine_window);\n    Context_draw_text(sine_window->context, \"Sine\",\n                       (sine_window->width / 2) - 16,\n                       (sine_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* Sine_constructor(PatchCore* patch_core) {\n\n    Sine* sine = (Sine*)malloc(sizeof(Sine));\n\n    if(!sine)\n        return (Unit*)sine;\n\n    if(!Unit_init((Unit*)sine, patch_core)) {\n\n        Object_delete((Object*)sine);\n        return (Unit*)0;\n    }\n\n    sine->output = Unit_create_output((Unit*)sine, 195, 75);\n    sine->freq_in = Unit_create_input((Unit*)sine, 5, 75);\n    Window_resize((Window*)sine, 200, 150);\n\n    if(!(sine->output && sine->freq_in)) {\n\n        Object_delete((Object*)sine);\n        return (Unit*)0;\n    }    \n   \n    sine->phase = 0;\n    sine->output->pull_sample_function = Sine_pull_sample_handler;\n    sine->unit.frame.window.paint_function = Sine_paint_handler;\n\n    return (Unit*)sine;\n}","#include \"slider.h\"\n\nvoid Slider_knob_move(Window* knob_window, int x, int y) {\n\n    Frame* knob = (Frame*)knob_window;\n    Slider* slider = (Slider*)knob->window.parent;\n    int height;\n\n    if(!slider)\n        return;\n\n    height = (slider->orientation ? \n             slider->window.width : slider->window.height) - 10;\n\n    if(slider->orientation)\n        y = x;\n\n    if(y < 0)\n        y = 0;\n\n    if(y > height)\n        y = height;\n\n    if(slider->knob_old_move)\n        slider->knob_old_move(knob_window, slider->orientation ? y : 0, \n                              slider->orientation ? 0 : y);\n}\n\nSlider* Slider_new(int x, int y, int width, int height, float min, float max) {\n\n    Slider* slider;\n\n    if(!(slider = (Slider*)malloc(sizeof(Slider))))\n        return slider;\n\n    if(!Window_init((Window*)slider, x, y, width, height, WIN_NODECORATION, (Context*)0)) {\n\n        free(slider);\n        return (Slider*)0;\n    }\n\n    if(slider->window.width > slider->window.height)\n        slider->orientation = 1;\n    else\n        slider->orientation = 0;\n\n\n    if(!(slider->knob = Frame_new(0, 0, slider->orientation ? 10 : width,\n                                  slider->orientation ? height : 10))) {\n\n        Object_delete((Object*)slider);\n        return (Slider*)0;\n    }\n\n    Window_insert_child((Window*)slider, (Window*)slider->knob);\n\n    slider->value = 0;\n    slider->min = min; \n    slider->max = max; \n    slider->knob_old_move = slider->knob->window.move_function; \n    slider->knob->window.move_function = Slider_knob_move;\n    slider->window.object.delete_function = Slider_delete_function;\n\n    return slider;\n}\n\nfloat Slider_get_value(Slider* slider) {\n\n    float y = (float)(slider->orientation ?\n                        slider->knob->window.x : slider->knob->window.y);\n    float height = (float)(slider->orientation ? \n                             slider->window.width : slider->window.height);\n\n    return (((y*(slider->min - slider->max))/(height - 10)) + slider->max);\n}\n\nvoid Slider_set_value(Slider* slider, float new_value) {\n\n    float new_y;\n    float height = (float)(slider->orientation ? \n                             slider->window.width : slider->window.height);\n\n    if(new_value > slider->max)\n        new_value = slider->max;\n\n    if(new_value < slider->min)\n       new_value = slider->min;\n\n    new_y = \n        (((-(height - 10)) / (slider->max - slider->min)) * (new_value - slider->min)) + (height - 10);\n\n    Window_move((Window*)slider->knob, slider->orientation ? (int)new_y : 0,\n                slider->orientation ? 0 : (int)new_y);\n}\n\nvoid Slider_delete_function(Object* slider_object) {\n\n    Slider* slider = (Slider*)slider_object;\n\n    Object_delete((Object*)slider->knob);\n    Window_delete_function(slider_object);\n}\n","#include \"split.h\"\n\nModule* Split_new() {\n\n    return Module_new(Split_constructor, \"Split\");\n}\n\nint Split_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n    \n    Split* split = (Split*)io->param_object;\n    \n    if(split->pulls == 0) {\n\n        if(!IO_pull_sample(split->input, sample_l, sample_r, sample_g))\n            return 0;\n    \n        split->last_sample_l = *sample_l;\n        split->last_sample_r = *sample_r;\n        split->last_sample_g = *sample_g;\n\n        //TODO: The below will still fail if there are disconnected outputs\n        //more than one unit downstream\n        if(split->output_one->connected_io && split->output_two->connected_io)\n            split->pulls++;\n    } else {\n\n        *sample_l = split->last_sample_l;\n        *sample_r = split->last_sample_r;\n        *sample_g = split->last_sample_g;\n        split->pulls = 0;\n    }\n\n    return 1;\n}\n\nvoid Split_paint_handler(Window* sine_window) {\n\n    Frame_paint_handler(sine_window);\n    Context_draw_text(sine_window->context, \"Split\",\n                       (sine_window->width / 2) - 12,\n                       (sine_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* Split_constructor(PatchCore* patch_core) {\n\n    Split* split = (Split*)malloc(sizeof(Split));\n\n    if(!split)\n        return (Unit*)split;\n\n    if(!Unit_init((Unit*)split, patch_core)) {\n\n        Object_delete((Object*)split);\n        return (Unit*)0;\n    }\n\n    split->output_one = Unit_create_output((Unit*)split, 195, 50);\n    split->output_two = Unit_create_output((Unit*)split, 195, 100);\n    split->input = Unit_create_input((Unit*)split, 5, 75);\n    Window_resize((Window*)split, 200, 150);\n\n    if(!(split->output_one && split->output_two && split->input)) {\n\n        Object_delete((Object*)split);\n        return (Unit*)0;\n    }    \n   \n    split->pulls = 0;\n    split->output_one->pull_sample_function = Split_pull_sample_handler;\n    split->output_two->pull_sample_function = Split_pull_sample_handler;\n    split->unit.frame.window.paint_function = Split_paint_handler;\n\n    return (Unit*)split;\n}\n","#include <math.h>\n#include \"square.h\"\n#include \"../platform/platformwrapper.h\"\n\nModule* Square_new() {\n\n    return Module_new(Square_constructor, \"Square\");\n}\n\nint Square_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n    \n    float in_sample_l, in_sample_r, in_sample_g;\n    Square* square = (Square*)io->param_object;\n    \n    if(!IO_pull_sample(square->freq_in, &in_sample_l, &in_sample_r, &in_sample_g))\n        return 0;\n\n    if(in_sample_l == 0) {\n\n        *sample_l = *sample_r = 0;\n        return 1;\n    }\n\n    *sample_l = *sample_r = square->phase > M_PI ? 1.0 : -1.0;\n    square->phase = (square->phase + (((2*M_PI) * in_sample_l)/SAMPLE_RATE));\n\n    if(square->phase > (2*M_PI))\n        square->phase -= (2*M_PI);\n\n    *sample_g = 1;\n\n    return 1;\n}\n\nvoid Square_paint_handler(Window* square_window) {\n\n    Frame_paint_handler(square_window);\n    Context_draw_text(square_window->context, \"Square\",\n                       (square_window->width / 2) - 24,\n                       (square_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* Square_constructor(PatchCore* patch_core) {\n\n    Square* square = (Square*)malloc(sizeof(Square));\n\n    if(!square)\n        return (Unit*)square;\n\n    if(!Unit_init((Unit*)square, patch_core)) {\n\n        Object_delete((Object*)square);\n        return (Unit*)0;\n    }\n\n    square->output = Unit_create_output((Unit*)square, 195, 75);\n    square->freq_in = Unit_create_input((Unit*)square, 5, 75);\n    Window_resize((Window*)square, 200, 150);\n\n    if(!(square->output && square->freq_in)) {\n\n        Object_delete((Object*)square);\n        return (Unit*)0;\n    }    \n   \n    square->phase = 0;\n    square->output->pull_sample_function = Square_pull_sample_handler;\n    square->unit.frame.window.paint_function = Square_paint_handler;\n\n    return (Unit*)square;\n}","\n#include \"styleutils.h\"\n\nvoid draw_panel(Context* context, int x, int y, int width, int height,\n               uint32_t color, int border_width, int invert) {\n\n    uint8_t r = RVAL(color);\n    uint8_t g = GVAL(color);\n    uint8_t b = BVAL(color);\n    uint32_t light_color = RGB(r > 155 ? 255 : r + 100, g > 155 ? 255 : g + 100, b > 155 ? 255 : b + 100);\n    uint32_t shade_color = RGB(r < 100 ? 0 : r - 100, g < 100 ? 0 : g - 100, b < 100 ? 0 : b - 100);\n    uint32_t temp;\n    int i;\n\n    if(invert) {\n\n        temp = shade_color;\n        shade_color = light_color;\n        light_color = temp;\n    }\n\n    for(i = 0; i < border_width; i++) {\n\n        //Top edge\n        Context_horizontal_line(context, x+i, y+i, width-(2*i), light_color);\n\n        //Left edge\n        Context_vertical_line(context, x+i, y+i+1, height-((i+1)*2), light_color);\n\n        //Bottom edge\n        Context_horizontal_line(context, x+i, (y+height)-(i+1), width-(2*i), shade_color);\n\n        //Right edge\n        Context_vertical_line(context, x+width-i-1, y+i+1, height-((i+1)*2), shade_color);\n    }\n}","#include \"unit.h\"\n#include \"../wslib/list.h\"\n\nUnit* Unit_new(PatchCore* patch_core) {\n\n    Unit* unit;\n    if(!(unit = (Unit*)malloc(sizeof(Unit))))\n        return unit;\n\n    if(!Unit_init(unit, patch_core)) {\n\n        Object_delete((Object*)unit);\n        return (Unit*)0;\n    }\n\n    return unit;\n}\n\nvoid Unit_move_function(Window* unit_window, int x, int y) {\n\n    Unit* unit = (Unit*)unit_window;\n\n    unit->old_move(unit_window, x, y);\n\n    //Cheap method to force elbow redraws\n    if(unit_window->parent) {\n\n        Window_invalidate(unit_window->parent, 0, 0,\n                          unit_window->parent->height - 1,\n                          unit_window->parent->width - 1);\n    }\n}\n\nint Unit_init(Unit* unit, PatchCore* patch_core) {\n\n    if(!Frame_init((Frame*)unit, 0, 0, 100, 100))\n        return 0;\n\n    unit->patch_core = patch_core;\n    unit->old_move = unit->frame.window.move_function;\n    unit->frame.window.move_function = Unit_move_function;\n\n    return 1;\n}\n\nIO* Unit_create_io(Unit* unit, int x, int y, uint8_t is_output) {\n\n    IO* io = IO_new(unit->patch_core, (Object*)unit, x, y, is_output);\n\n    if(!io)\n        return io;\n\n    Window_insert_child((Window*)unit, (Window*)io);\n\n    return io;\n}\n\nIO* Unit_create_output(Unit* unit, int x, int y) {\n\n    IO* io = Unit_create_io(unit, x, y, 1);\n\n    return io;\n}\n\nIO* Unit_create_input(Unit* unit, int x, int y) {\n\n    return Unit_create_io(unit, x, y, 0);\n}\n\nvoid Unit_delete(Object* unit_object) {\n\n    Window_delete_function(unit_object);\n}\n","#include \"vca.h\"\n\nModule* VCA_new() {\n\n    return Module_new(VCA_constructor, \"VCA\");\n}\n\nint VCA_pull_sample_handler(IO* io, float* sample_l, float* sample_r, float* sample_g) {\n    \n    float in_sample_l, in_sample_r, in_sample_g, gain;\n    VCA* vca = (VCA*)io->param_object;\n    \n    if(!IO_pull_sample(vca->level_in, &in_sample_l, &in_sample_r, &in_sample_g))\n        return 0;\n\n    //Should probably run this through my standard gain curve\n    gain = (in_sample_l + 1) / 2;\n\n    if(!IO_pull_sample(vca->signal_in, &in_sample_l, &in_sample_r, sample_g))\n        return 0;\n\n    *sample_l = in_sample_l * gain;\n    *sample_r = in_sample_r * gain;\n    *sample_g = (in_sample_g > -1.0 && *sample_g > -1.0) ? 1.0 : -1.0;\n    \n    return 1;\n}\n\nvoid VCA_paint_handler(Window* sine_window) {\n\n    Frame_paint_handler(sine_window);\n    Context_draw_text(sine_window->context, \"VCA\",\n                       (sine_window->width / 2) - 12,\n                       (sine_window->height / 2) - 6,\n                       WIN_BORDERCOLOR);     \n}\n\nUnit* VCA_constructor(PatchCore* patch_core) {\n\n    VCA* vca = (VCA*)malloc(sizeof(VCA));\n\n    if(!vca)\n        return (Unit*)vca;\n\n    if(!Unit_init((Unit*)vca, patch_core)) {\n\n        Object_delete((Object*)vca);\n        return (Unit*)0;\n    }\n\n    vca->output = Unit_create_output((Unit*)vca, 195, 75);\n    vca->level_in = Unit_create_input((Unit*)vca, 5, 50);\n    vca->signal_in = Unit_create_input((Unit*)vca, 5, 100);\n    Window_resize((Window*)vca, 200, 150);\n\n    if(!(vca->output && vca->level_in && vca->signal_in)) {\n\n        Object_delete((Object*)vca);\n        return (Unit*)0;\n    }    \n   \n    vca->output->pull_sample_function = VCA_pull_sample_handler;\n    vca->unit.frame.window.paint_function = VCA_paint_handler;\n\n    return (Unit*)vca;\n}\n","#include <inttypes.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"window.h\"\n#include \"styleutils.h\"\n\n\n//================| Window Class Implementation |================//\n\n//Here's a quick, crappy pseudo-RNG since you probably don't have one\nuint8_t pseudo_rand_8() {\n\n    static uint16_t seed = 0;\n    return (uint8_t)(seed = (12657 * seed + 12345) % 256);\n}\n\nvoid print_window(Window* window) {\n\n    printf(\"\\n-----------------\\nNEW WINDOW\\n-----------------\\n\");\n    printf(\"Object deleter #: %p\\n\", (void*)window->object.delete_function);\n    printf(\"Parent pointer: 0x%08X\\n\", (int)window->parent);\n    printf(\"Window ID: %i\\n\", window->id);\n    printf(\"Window position: (%i, %i)\\n\", window->x, window->y);\n    printf(\"Window dimensions: %i x %i\\n\", window->width, window->height);\n    printf(\"Window flags: 0x%04X\\n\", window->flags);\n    printf(\"Context pointer: 0x%08X\\n\", (int)window->context);\n    printf(\"Drag child pointer: 0x%08X\\n\", (int)window->drag_child);\n    printf(\"Active child pointer: 0x%08X\\n\", (int)window->active_child);\n    printf(\"Over child pointer: 0x%08X\\n\", (int)window->over_child);\n    printf(\"Child list pointer: 0x%08X\\n\", (int)window->children);\n    printf(\"Drag offsets: (%i, %i)\\n\", window->drag_off_x, window->drag_off_y);\n    printf(\"Last button state: 0x%02X\\n\", window->last_button_state);\n    printf(\"Click cycle: %i\\n\", window->click_cycle);\n    printf(\"Paint function #: %p\\n\", (void*)window->paint_function);\n    printf(\"Mousedown function #: %p\\n\", (void*)window->mousedown_function);\n    printf(\"Mouseup function #: %p\\n\", (void*)window->mouseup_function);\n    printf(\"Mouseover function #: %p\\n\", (void*)window->mouseover_function);\n    printf(\"Mouseout function #: %p\\n\", (void*)window->mouseout_function);\n    printf(\"Mousemove function #: %p\\n\", (void*)window->mousemove_function);\n    printf(\"Mouseclick function #: %p\\n\", (void*)window->mouseclick_function);\n    printf(\"Move function #: %p\\n\", (void*)window->move_function);\n    if(window->title)\n        printf(\"Window title: %s\\n\", window->title);\n    else\n        printf(\"Window title:\\n\");\n}\n\n//Window constructor\nWindow* Window_new(int16_t x, int16_t y, uint16_t width,\n                   uint16_t height, uint16_t flags, Context* context) {\n\n    //Try to allocate space for a new WindowObj and fail through if malloc fails\n    Window* window;\n    if(!(window = (Window*)malloc(sizeof(Window))))\n        return window;\n\n    //Attempt to initialize the new window\n    if(!Window_init(window, x, y, width, height, flags, context)) {\n    \n        free(window);\n        return (Window*)0;\n    }\n\n    return window;\n}\n\n//Seperate object allocation from initialization so we can implement\n//our inheritance scheme\nint Window_init(Window* window, int16_t x, int16_t y, uint16_t width,\n                uint16_t height, uint16_t flags, Context* context) {\n\n    static unsigned int handle_source = 0;\n\n    Object_init((Object*)window, Window_delete_function);\n\n    //Moved over here from the desktop \n    //Create child list or clean up and fail\n    if(!(window->children = List_new()))\n        return 0;\n\n    //Assign the property values\n    window->id = ++handle_source;\n    window->x = x;\n    window->y = y;\n    window->width = width;\n    window->height = height;\n    window->context = context ? Context_new_from(context) : context;\n    window->flags = flags;\n    window->parent = (Window*)0;\n    window->drag_child = (Window*)0;\n    window->drag_off_x = 0;\n    window->drag_off_y = 0;\n    window->last_button_state = 0;\n    window->click_cycle = 0;\n    window->paint_function = Window_paint_handler;\n    window->mousedown_function = (WindowMousedownHandler)0;\n    window->mouseup_function = (WindowMouseupHandler)0;\n    window->mouseover_function = (WindowMouseoverHandler)0;\n    window->mouseout_function = (WindowMouseoutHandler)0;\n    window->mousemove_function = (WindowMousemoveHandler)0;\n    window->mouseclick_function = (WindowMouseclickHandler)0;\n    window->move_function = Window_move_function;\n    window->active_child = (Window*)0;\n    window->over_child = (Window*)0;\n    window->title = (char*)0;\n\n    return 1;\n}\n\nvoid Window_mousedown(Window* window, int x, int y) {\n\n    if(window->click_cycle != 2) \n        return;\n\n    window->click_cycle = 3;\n\n    if(window->mousedown_function)\n        window->mousedown_function(window, x, y);\n}\n\nvoid Window_mouseup(Window* window, int x, int y) {\n\n    if(window->mouseup_function)\n        window->mouseup_function(window, x, y);\n\n    if(window->click_cycle == 3)\n        Window_mouseclick(window, x, y);\n\n    window->click_cycle = 1;\n}\n\nvoid Window_mouseover(Window* window) {\n\n    window->click_cycle = 1;\n\n    if(window->mouseover_function)\n        window->mouseover_function(window);\n}\n\nvoid Window_mouseout(Window* window) {\n\n    int old_click_cycle = window->click_cycle;\n\n    window->click_cycle = 0;\n\n    if(old_click_cycle == 3)\n        Window_mouseup(window, 0, 0);\n\n    if(window->over_child) {\n\n        Window_mouseout(window->over_child);\n        window->over_child = (Window*)0;\n    }\n\n    if(window->mouseout_function)\n        window->mouseout_function(window);    \n}\n\nvoid Window_mousemove(Window* window, int x, int y) {\n\n    if(window->mousemove_function)\n        window->mousemove_function(window, x, y);\n}\n\nvoid Window_mouseclick(Window* window, int x, int y) {\n\n    if(window->mouseclick_function)\n        window->mouseclick_function(window, x, y);\n}\n\n//Recursively get the absolute on-screen x-coordinate of this window\nint Window_screen_x(Window* window) {\n\n    if(window->parent)\n        return window->x + Window_screen_x(window->parent);\n    \n    return window->x;\n}\n\n//Recursively get the absolute on-screen y-coordinate of this window\nint Window_screen_y(Window* window) {\n\n    if(window->parent)\n        return window->y + Window_screen_y(window->parent);\n    \n    return window->y;\n}\n\nvoid Window_draw_border(Window* window) {\n\n    uint32_t tb_color;\n    int screen_x = Window_screen_x(window);\n    int screen_y = Window_screen_y(window);\n    \n    //Outer border\n    draw_panel(window->context, screen_x, screen_y, window->width,\n               window->height, WIN_BGCOLOR, 1, 0);\n    \n    //Title border\n    draw_panel(window->context, screen_x+3, screen_y+3, window->width - 6,\n               22, WIN_BGCOLOR, 1, 1);\n    \n    //Body border\n    draw_panel(window->context, screen_x+3, screen_y+27, window->width - 6,\n               window->height - 30, WIN_BGCOLOR, 1, 1);\n    \n    //Left frame\n    Context_fill_rect(window->context, screen_x+1, screen_y+1, 2, \n                      window->height - 2, WIN_BGCOLOR); \n    \n    //Right frame\n    Context_fill_rect(window->context, screen_x + window->width - 3,\n                      screen_y + 1, 2, window->height - 2, WIN_BGCOLOR); \n    \n    //Top frame\n    Context_fill_rect(window->context, screen_x + 3, screen_y + 1,\n                      window->width - 6, 2, WIN_BGCOLOR); \n    \n    //Mid frame\n    Context_fill_rect(window->context, screen_x + 3, screen_y + 25,\n                      window->width - 6, 2, WIN_BGCOLOR); \n    \n    //Bottom frame\n    Context_fill_rect(window->context, screen_x + 3, screen_y + window->height - 3,\n                      window->width - 6, 2, WIN_BGCOLOR); \n        \n    //Button\n    draw_panel(window->context, screen_x + window->width - 24, screen_y + 4,\n               20, 20, WIN_BGCOLOR, 1, 0);\n    Context_fill_rect(window->context, screen_x + window->width - 23,\n                      screen_y + 5, 18, 18, WIN_BGCOLOR); \n    \n    //Titlebar\n    if(window->parent->active_child == window)\n        tb_color = RGB(182, 0, 0);\n    else \n        tb_color = RGB(238, 203, 137);\n    \n    Context_fill_rect(window->context, screen_x + 4, screen_y + 4,\n                      window->width - 28, 20, tb_color);\n\n    //Draw the window title\n    Context_draw_text(window->context, window->title, (WIN_TITLEHEIGHT / 2) + screen_x - 6,\n                      (WIN_TITLEHEIGHT / 2) + screen_y - 6,\n                      window->parent->active_child == window ? \n                          WIN_TEXTCOLOR : WIN_TEXTCOLOR_INACTIVE);\n\n}\n\n//Apply clipping for window bounds without subtracting child window rects\nvoid Window_apply_bound_clipping(Window* window, Context* context, int in_recursion, List* dirty_regions) {\n\n    Rect *temp_rect, *current_dirty_rect, *clone_dirty_rect;\n    int screen_x, screen_y, i;\n    List* clip_windows;\n    Window* clipping_window;\n\n    //Can't do this without a context\n    if(!context)\n        return;\n\n    //Build the visibility rectangle for this window\n    //If the window is decorated and we're recursing, we want to limit\n    //the window's drawable area to the area inside the window decoration.\n    //If we're not recursing, however, it means we're about to paint \n    //ourself and therefore we want to wait until we've finished painting\n    //the window border to shrink the clipping area \n    screen_x = Window_screen_x(window);\n    screen_y = Window_screen_y(window);\n    \n    if((!(window->flags & WIN_NODECORATION)) && in_recursion) {\n\n        //Limit client drawable area \n        screen_x += WIN_BORDERWIDTH;\n        screen_y += WIN_TITLEHEIGHT;\n        temp_rect = Rect_new(screen_y, screen_x,\n                             screen_y + window->height - WIN_TITLEHEIGHT - WIN_BORDERWIDTH - 1, \n                             screen_x + window->width - (2*WIN_BORDERWIDTH) - 1);\n    } else {\n\n        temp_rect = Rect_new(screen_y, screen_x, screen_y + window->height - 1, \n                             screen_x + window->width - 1);\n    }\n\n    //If there's no parent (meaning we're at the top of the window tree)\n    //then we just add our rectangle and exit\n    //Here's our change: If we were passed a dirty region list, we first\n    //clone those dirty rects into the clipping region and then intersect\n    //the top-level window bounds against it so that we're limited to the\n    //dirty region from the outset\n    if(!window->parent) {\n\n        if(dirty_regions) {\n\n            //Clone the dirty regions and put them into the clipping list\n            for(i = 0; i < dirty_regions->count; i++) {\n            \n                //Clone\n                current_dirty_rect = (Rect*)List_get_at(dirty_regions, i);\n                clone_dirty_rect = Rect_new(current_dirty_rect->top,\n                                            current_dirty_rect->left,\n                                            current_dirty_rect->bottom,\n                                            current_dirty_rect->right);\n                \n                //Add\n                Context_add_clip_rect(context, clone_dirty_rect);\n            }\n\n            //Finally, intersect this top level window against them\n            Context_intersect_clip_rect(context, temp_rect);\n\n        } else {\n\n            Context_add_clip_rect(context, temp_rect);\n        }\n\n        return;\n    }\n\n    //Otherwise, we first reduce our clipping area to the visibility area of our parent\n    Window_apply_bound_clipping(window->parent, context, 1, dirty_regions);\n\n    //Now that we've reduced our clipping area to our parent's clipping area, we can\n    //intersect our own bounds rectangle to get our main visible area  \n    Context_intersect_clip_rect(context, temp_rect);\n\n    //And finally, we subtract the rectangles of any siblings that are occluding us \n    clip_windows = Window_get_windows_above(window->parent, window);\n\n    while(clip_windows->count) {\n        \n        clipping_window = (Window*)List_remove_at(clip_windows, 0);\n\n        //Get a rectangle from the window, subtract it from the clipping \n        //region, and dispose of it\n        screen_x = Window_screen_x(clipping_window);\n        screen_y = Window_screen_y(clipping_window);\n\n        temp_rect = Rect_new(screen_y, screen_x,\n                             screen_y + clipping_window->height - 1,\n                             screen_x + clipping_window->width - 1);\n        Context_subtract_clip_rect(context, temp_rect);\n        Object_delete((Object*)(Object*)temp_rect);\n    }\n\n    //Dispose of the used-up list \n    Object_delete((Object*)clip_windows);\n}\n\nvoid Window_update_title(Window* window) {\n\n    int screen_x, screen_y;\n\n    if(!window->context || \n       (window->flags & WIN_HIDDEN) ||\n       (window->flags & WIN_NODECORATION))\n        return;\n\n    //Start by limiting painting to the window's visible area\n    Window_apply_bound_clipping(window, window->context, 0, (List*)0);\n\n    //Draw border\n    Window_draw_border(window);\n\n    Context_clear_clip_rects(window->context);\n}\n\n//Request a repaint of a certain region of a window\nvoid Window_invalidate(Window* window, int top, int left, int bottom, int right) {\n\n    List* dirty_regions;\n    Rect* dirty_rect;\n\n    //This function takes coordinates in terms of window coordinates\n    //So we need to convert them to screen space \n    int origin_x = Window_screen_x(window);\n    int origin_y = Window_screen_y(window);\n    top += origin_y;\n    bottom += origin_y;\n    left += origin_x;\n    right += origin_x;\n    \n    //Attempt to create a new dirty rect list \n    if(!(dirty_regions = List_new()))\n        return;\n\n    if(!(dirty_rect = Rect_new(top, left, bottom, right))) {\n\n        Object_delete((Object*)dirty_regions);\n        return;\n    }\n\n    if(!List_add(dirty_regions, (Object*)dirty_rect)) {\n\n        Object_delete((Object*)dirty_regions);\n        return;\n    }\n\n    Window_paint(window, dirty_regions, 0);\n\n    //Clean up the dirty rect list\n    Object_delete((Object*)dirty_regions);\n}\n\n//Another override-redirect function\nvoid Window_paint(Window* window, List* dirty_regions, uint8_t paint_children) {\n\n    int i, j, screen_x, screen_y, child_screen_x, child_screen_y;\n    Window* current_child;\n    Rect* temp_rect;\n\n    //Can't paint without a context\n    if(!window->context || (window->flags & WIN_HIDDEN))\n        return;\n\n    //Start by limiting painting to the window's visible area\n    Window_apply_bound_clipping(window, window->context, 0, dirty_regions);\n\n    //Set the context translation\n    screen_x = Window_screen_x(window);\n    screen_y = Window_screen_y(window);\n\n    //If we have window decorations turned on, draw them and then further\n    //limit the clipping area to the inner drawable area of the window \n    if(!(window->flags & WIN_NODECORATION)) {\n\n        //Draw border\n        Window_draw_border(window);\n\n        //Limit client drawable area \n        screen_x += WIN_BORDERWIDTH;\n        screen_y += WIN_TITLEHEIGHT;\n        temp_rect = Rect_new(screen_y, screen_x,\n                             screen_y + window->height - WIN_TITLEHEIGHT - WIN_BORDERWIDTH - 1, \n                             screen_x + window->width - (2*WIN_BORDERWIDTH) - 1);\n        Context_intersect_clip_rect(window->context, temp_rect);\n    }\n\n    //Then subtract the screen rectangles of any children \n    //NOTE: We don't do this in Window_apply_bound_clipping because, due to \n    //its recursive nature, it would cause the screen rectangles of all of \n    //our parent's children to be subtracted from the clipping area -- which\n    //would eliminate this window. \n    for(i = 0; i < window->children->count; i++) {\n\n        current_child = (Window*)List_get_at(window->children, i);\n\n        if(current_child->flags & WIN_HIDDEN)\n            continue;\n\n        child_screen_x = Window_screen_x(current_child);\n        child_screen_y = Window_screen_y(current_child);\n\n        temp_rect = Rect_new(child_screen_y, child_screen_x,\n                             child_screen_y + current_child->height - 1,\n                             child_screen_x + current_child->width - 1);\n        Context_subtract_clip_rect(window->context, temp_rect);\n        Object_delete((Object*)temp_rect);\n    }\n\n    //Finally, with all the clipping set up, we can set the context's 0,0 to the top-left corner\n    //of the window's drawable area, and call the window's final paint function \n    window->context->translate_x = screen_x;\n    window->context->translate_y = screen_y;\n    window->paint_function(window);\n\n    //Now that we're done drawing this window, we can clear the changes we made to the context\n    Context_clear_clip_rects(window->context);\n    window->context->translate_x = 0;\n    window->context->translate_y = 0;\n    \n    //Even though we're no longer having all mouse events cause a redraw from the desktop\n    //down, we still need to call paint on our children in the case that we were called with\n    //a dirty region list since each window needs to be responsible for recursively checking\n    //if its children were dirtied \n    if(!paint_children)\n        return;\n\n    for(i = 0; i < window->children->count; i++) {\n\n        current_child = (Window*)List_get_at(window->children, i);\n\n        if(dirty_regions) {\n\n            //Check to see if the child is affected by any of the\n            //dirty region rectangles\n            for(j = 0; j < dirty_regions->count; j++) {\n            \n                temp_rect = (Rect*)List_get_at(dirty_regions, j);\n                \n                screen_x = Window_screen_x(current_child);\n                screen_y = Window_screen_y(current_child);\n\n                if(temp_rect->left <= (screen_x + current_child->width - 1) &&\n                   temp_rect->right >= screen_x &&\n                   temp_rect->top <= (screen_y + current_child->height - 1) &&\n                   temp_rect->bottom >= screen_y)\n                    break;\n            }\n\n            //Skip drawing this child if no intersection was found\n            if(j == dirty_regions->count)\n                continue;\n        }\n\n        //Otherwise, recursively request the child to redraw its dirty areas\n        Window_paint(current_child, dirty_regions, 1);\n    }\n}\n\n//This is the default paint method for a new window\nvoid Window_paint_handler(Window* window) {\n\n    //Fill in the window background\n    Context_fill_rect(window->context, 0, 0,\n                      window->width, window->height, WIN_BGCOLOR);\n}\n\n//Used to get a list of windows overlapping the passed window\nList* Window_get_windows_above(Window* parent, Window* child) {\n\n    int i;\n    Window* current_window;\n    List* return_list;\n\n    //Attempt to allocate the output list\n    if(!(return_list = List_new()))\n        return return_list;\n\n    //We just need to get a list of all items in the\n    //child list at higher indexes than the passed window\n    //We start by finding the passed child in the list\n    for(i = 0; i < parent->children->count; i++)\n        if(child == (Window*)List_get_at(parent->children, i))\n            break;\n\n    //Now we just need to add the remaining items in the list\n    //to the output (IF they overlap, of course)\n    //NOTE: As a bonus, this will also automatically fall through\n    //if the window wasn't found\n    for(i++; i < parent->children->count; i++) {\n\n        current_window = (Window*)List_get_at(parent->children, i);\n\n        if(current_window->flags & WIN_HIDDEN)\n            continue;\n\n        //Our good old rectangle intersection logic\n        if(current_window->x <= (child->x + child->width - 1) &&\n\t\t   (current_window->x + current_window->width - 1) >= child->x &&\n\t\t   current_window->y <= (child->y + child->height - 1) &&\n\t\t   (current_window->y + current_window->height - 1) >= child->y)\n            List_add(return_list, (Object*)current_window); //Insert the overlapping window\n    }\n\n    return return_list; \n}\n\n//Used to get a list of windows which the passed window overlaps\n//Same exact thing as get_windows_above, but goes backwards through\n//the list. Could probably be made a little less redundant if you really wanted\nList* Window_get_windows_below(Window* parent, Window* child) {\n\n    int i;\n    Window* current_window;\n    List* return_list;\n\n    //Attempt to allocate the output list\n    if(!(return_list = List_new()))\n        return return_list;\n\n    //We just need to get a list of all items in the\n    //child list at higher indexes than the passed window\n    //We start by finding the passed child in the list\n    for(i = parent->children->count - 1; i > -1; i--)\n        if(child == (Window*)List_get_at(parent->children, i))\n            break;\n\n    //Now we just need to add the remaining items in the list\n    //to the output (IF they overlap, of course)\n    //NOTE: As a bonus, this will also automatically fall through\n    //if the window wasn't found\n    for(i--; i > -1; i--) {\n\n        current_window = (Window*)List_get_at(parent->children, i);\n\n        if(current_window->flags & WIN_HIDDEN)\n            continue;\n\n        //Our good old rectangle intersection logic\n        if(current_window->x <= (child->x + child->width - 1) &&\n\t\t   (current_window->x + current_window->width - 1) >= child->x &&\n\t\t   current_window->y <= (child->y + child->height - 1) &&\n\t\t   (current_window->y + current_window->height - 1) >= child->y)\n            List_add(return_list, (Object*)current_window); //Insert the overlapping window\n    }\n\n    return return_list; \n}\n\n//Breaking \nvoid Window_raise(Window* window, uint8_t do_draw) {\n\n    int i;\n    Window* parent;\n    Window* last_active = (Window*)0;\n\n    if(window->flags & WIN_NORAISE)\n        return;\n\n    if(!window->parent)\n        return;\n\n    parent = window->parent;\n\n    if(parent->active_child == window)\n        return;\n\n    last_active = parent->active_child;\n\n    //Find the child in the list\n    for(i = 0; i < parent->children->count; i++)\n        if((Window*)List_get_at(parent->children, i) == window)\n            break;\n\n    List_remove_at(parent->children, i); //Pull window out of list\n    List_add(parent->children, (void*)window); //Insert at the top\n\n    //Make it active \n    parent->active_child = window;\n\n    //Do a redraw if it was requested\n    if(!do_draw)\n        return;\n\n    Window_paint(window, (List*)0, 1);\n\n    //Make sure the old active window gets an updated title color \n    if(last_active) \n        Window_update_title(last_active);\n}\n\nvoid Window_move(Window* window, int new_x, int new_y) {\n\n    if(window->move_function)\n        window->move_function(window, new_x, new_y);\n    else\n        Window_move_function(window, new_x, new_y);\n}\n\n//We're wrapping this guy so that we can handle any needed redraw\nvoid Window_move_function(Window* window, int new_x, int new_y) {\n\n    int i;\n    int old_x = window->x;\n    int old_y = window->y;\n    Rect new_window_rect;\n    List *replacement_list, *dirty_list, *dirty_windows;\n\n    //To make life a little bit easier, we'll make the not-unreasonable \n    //rule that if a window is moved, it must become the top-most window\n    Window_raise(window, 0); //Raise it, but don't repaint it yet\n\n    //We'll hijack our dirty rect collection from our existing clipping operations\n    //So, first we'll get the visible regions of the original window position\n    Window_apply_bound_clipping(window, window->context, 0, (List*)0);\n\n    //Temporarily update the window position\n    window->x = new_x;\n    window->y = new_y;\n\n    //Calculate the new bounds\n    new_window_rect.top = Window_screen_y(window);\n    new_window_rect.left = Window_screen_x(window);\n    new_window_rect.bottom = new_window_rect.top + window->height - 1;\n    new_window_rect.right = new_window_rect.left + window->width - 1;\n\n    //Reset the window position\n    window->x = old_x;\n    window->y = old_y;\n\n    //Now, we'll get the *actual* dirty area by subtracting the new location of\n    //the window \n    Context_subtract_clip_rect(window->context, &new_window_rect);\n\n    //Now that the context clipping tools made the list of dirty rects for us,\n    //we can go ahead and steal the list it made for our own purposes\n    //(yes, it would be cleaner to spin off our boolean rect functions so that\n    //they can be used both here and by the clipping region tools, but I ain't \n    //got time for that junk)\n    if(!(replacement_list = List_new())) {\n\n        Context_clear_clip_rects(window->context);\n        return;\n    }\n\n    dirty_list = window->context->clip_rects;\n    window->context->clip_rects = replacement_list;\n\n    //Now, let's get all of the siblings that we overlap before the move\n    dirty_windows = Window_get_windows_below(window->parent, window);\n\n    window->x = new_x;\n    window->y = new_y;\n\n    //And we'll repaint all of them using the dirty rects\n    //(removing them from the list as we go for convenience)\n    while(dirty_windows->count)\n        Window_paint((Window*)List_remove_at(dirty_windows, 0), dirty_list, 1);\n\n    //The one thing that might still be dirty is the parent we're inside of\n    Window_paint(window->parent, dirty_list, 0);\n\n    //We're done with the lists, so we can dump them\n    Object_delete((Object*)dirty_list);\n    Object_delete((Object*)dirty_windows);\n\n    //With the dirtied siblings redrawn, we can do the final update of \n    //the window location and paint it at that new position\n    Window_paint(window, (List*)0, 1);\n}\n\n//Interface between windowing system and mouse device\nvoid Window_process_mouse(Window* window, uint16_t mouse_x,\n                          uint16_t mouse_y, uint8_t mouse_buttons) {\n\n    int i, inner_x1, inner_y1, inner_x2, inner_y2;\n    Window* child;\n\n    if(window->drag_child) {\n\n        if(mouse_buttons) {\n\n            //Changed to use \n            Window_move(window->drag_child, mouse_x - window->drag_off_x,\n                        mouse_y - window->drag_off_y);\n            return;\n        } else {\n\n            window->drag_child = (Window*)0;\n        }\n    }\n\n    //If we had a button depressed, then we need to see if the mouse was\n    //over any of the child windows\n    //We go front-to-back in terms of the window stack for free occlusion\n    for(i = window->children->count - 1; i >= 0; i--) {\n\n        child = (Window*)List_get_at(window->children, i);\n\n        //If mouse isn't window bounds, we can't possibly be interacting with it \n        if(!(mouse_x >= child->x && mouse_x < (child->x + child->width) &&\n           mouse_y >= child->y && mouse_y < (child->y + child->height)) || \n           (child->flags & WIN_HIDDEN)) \n            continue;\n\n        //Do mouseover and mouseout events \n        if(child != window->over_child) {\n\n            if(window->over_child)\n                Window_mouseout(window->over_child);\n            else\n                Window_mouseout(window);\n\n            window->over_child = child;\n            Window_mouseover(window->over_child);\n        }            \n\n        //Now we'll check to see if we're dragging a titlebar\n        if(mouse_buttons && !window->last_button_state) {\n\n            //Let's adjust things so that a raise happens whenever we click inside a \n            //child, to be more consistent with most other GUIs\n            Window_raise(child, 1);\n\n            //See if the window has bodydrag enabled or \n            //See if the mouse position lies within the bounds of the current titlebar\n            //We check the decoration flag since we can't drag a window without a titlebar\n            if((child->flags & WIN_BODYDRAG) ||  (\n               !(child->flags & WIN_BODYDRAG) && !(child->flags & WIN_NODECORATION) &&\n               mouse_y >= child->y && mouse_y < (child->y + WIN_TITLEHEIGHT)\n               )) {\n\n                //We'll also set this window as the window being dragged\n                //until such a time as the mouse is released\n                window->drag_off_x = mouse_x - child->x;\n                window->drag_off_y = mouse_y - child->y;\n                window->drag_child = child;\n            }\n        }\n        \n        break;\n    }\n\n    //Do any not-over-a-child handling\n    if(i < 0) {\n\n        //If we were previously over a child, handle a mouseout event on it and clear the pointer\n        if(window->over_child) {\n\n            Window_mouseout(window->over_child);\n            window->over_child = (Window*)0;\n            \n            //We reentered the parent from a child, so fire a mouseover on the parent \n            Window_mouseover(window);\n        }\n\n        //If we didn't find a target in the search, then we ourselves are the target of any clicks\n        if(mouse_buttons && !window->last_button_state) \n            Window_mousedown(window, mouse_x, mouse_y);\n\n        if(!mouse_buttons && window->last_button_state)\n            Window_mouseup(window, mouse_x, mouse_y);\n\n        Window_mousemove(window, mouse_x, mouse_y);\n    } else {\n\n        //Found a target, so forward the mouse event to that window and quit looking\n        Window_process_mouse(child, mouse_x - child->x, mouse_y - child->y, mouse_buttons); \n\n        //Cancel any body drag if the mouse was found to be over a child in the dragged child \n        if((child->flags & WIN_BODYDRAG) && (window->drag_child == child) && !!child->over_child)\n            window->drag_child = (Window*)0;\n    }\n\n    //Update the stored mouse button state to match the current state \n    window->last_button_state = mouse_buttons;\n    if(window->click_cycle == 1)\n        window->click_cycle = 2;\n}\n\nvoid Window_update_context(Window* window, Context* context) {\n\n    int i;\n    Context* old_context = window->context;\n\n    window->context = context ? Context_new_from(context) : context;\n\n    for(i = 0; i < window->children->count; i++)\n        Window_update_context((Window*)List_get_at(window->children, i), context);\n\n    if(old_context)\n        Object_delete((Object*)old_context);\n}\n\n//Quick wrapper for shoving a new entry into the child list\nvoid Window_insert_child(Window* window, Window* child) {\n\n    child->parent = window;\n    List_add(window->children, (Object*)child);   \n    Window_update_context(child, window->context);\n    Window_raise(child, 1);\n}\n\n//A method to automatically create a new window in the provided parent window\nWindow* Window_create_window(Window* window, int16_t x, int16_t y,  \n                             uint16_t width, int16_t height, uint16_t flags) {\n\n    //Attempt to create the window instance\n    Window* new_window;\n    if(!(new_window = Window_new(x, y, width, height, flags, window->context)))\n        return new_window;\n\n    //Attempt to add the window to the end of the parent's children list\n    //If we fail, make sure to clean up all of our allocations so far \n    if(!List_add(window->children, (void*)new_window)) {\n\n        Object_delete((Object*)new_window);\n        return (Window*)0;\n    }\n\n    //Set the new child's parent \n    new_window->parent = window;\n\n    Window_raise(new_window, 1);\n\n    return new_window;\n}\n\n//Assign a string to the title of the window\nvoid Window_set_title(Window* window, char* new_title) {\n\n    int len, i;\n\n    //Make sure to free any preexisting title \n    if(window->title) {\n\n        for(len = 0; window->title[len]; len++);\n        free(window->title);\n    }\n\n    //We don't have strlen, so we're doing this manually\n    for(len = 0; new_title[len]; len++);\n\n    //Try to allocate new memory to clone the string\n    //(+1 because of the trailing zero in a c-string)\n    if(!(window->title = (char*)malloc((len + 1) * sizeof(char))))\n        return;\n\n    //Clone the passed string into the window's title\n    //Including terminating zero\n    for(i = 0; i <= len; i++)\n        window->title[i] = new_title[i];\n\n    //Make sure the change is reflected on-screen\n    if(window->flags & WIN_NODECORATION)\n        Window_invalidate(window, 0, 0, window->height - 1, window->width - 1);\n    else\n        Window_update_title(window);\n}\n\n//Add the characters from the passed string to the end of the window title\nvoid Window_append_title(Window* window, char* additional_chars) {\n\n    char* new_string;\n    int original_length, additional_length, i;\n\n    //Set the title if there isn't already one\n    if(!window->title) {\n\n        Window_set_title(window, additional_chars);\n        return;\n    }\n\n    //Get the length of the original string\n    for(original_length = 0; window->title[original_length]; original_length++);\n\n    //Get the length of the new string\n    for(additional_length = 0; additional_chars[additional_length]; additional_length++);\n\n    //Try to malloc a new string of the needed size\n    if(!(new_string = (char*)malloc(sizeof(char) * (original_length + additional_length + 1)))) {\n        return;\n    }\n\n    //Copy the base string into the new string\n    for(i = 0; window->title[i]; i++)\n        new_string[i] = window->title[i];\n\n    //Copy the appended chars into the new string\n    for(i = 0; additional_chars[i]; i++)\n        new_string[original_length + i] = additional_chars[i];\n\n    //Add the final zero char\n    new_string[original_length + i] = 0;\n\n    //And swap the string pointers\n    free(window->title);\n    window->title = new_string;\n\n    //Make sure the change is reflected on-screen\n    if(window->flags & WIN_NODECORATION)\n        Window_invalidate(window, 0, 0, window->height - 1, window->width - 1);\n    else\n        Window_update_title(window); \n}\n\nvoid Window_hide(Window* window) {\n\n    List* dirty_list;\n    Rect* dirty_rect;\n\n    if(!window->parent || (window->flags & WIN_HIDDEN))\n        return;\n\n    window->flags |= WIN_HIDDEN;\n    \n    //Build a dirty rect list for the mouse area\n    if(!(dirty_list = List_new()))\n        return;\n\n    if(!(dirty_rect = Rect_new(Window_screen_y(window), Window_screen_x(window), \n                               Window_screen_y(window) + window->height - 1,\n                               Window_screen_x(window) + window->width - 1))) {\n\n        Object_delete((Object*)dirty_list);\n        return;\n    }\n\n    List_add(dirty_list, (Object*)dirty_rect);\n\n    //Do a dirty update for the desktop, which will, in turn, do a \n    //dirty update for all affected child windows\n    Window_paint(window->parent, dirty_list, 1); \n\n    Object_delete((Object*)dirty_list);\n}\n\nvoid Window_show(Window* window) {\n\n    if(!(window->flags & WIN_HIDDEN))\n        return;\n\n    window->flags &= ~WIN_HIDDEN;\n\n    Window_paint(window, (List*)0, 1);\n}\n\nvoid Window_delete_function(Object* window_object) {\n\n    int i;\n    Window *window = (Window*)window_object;\n\n    if(!window_object)\n        return;\n\n    Window_hide(window);\n\n    Object_delete((Object*)window->children);\n\n    if(window->parent) {\n\n        for(i = 0;\n            i < window->parent->children->count && \n            (Window*)List_get_at(window->parent->children, i) != window; \n            i++);\n\n        if(i < window->parent->children->count)\n            List_remove_at(window->parent->children, i);\n\n        if(window->parent->active_child == window) {\n\n            if(window->parent->children->count) {\n\n                window->parent->active_child =\n                    (Window*)List_get_at(window->parent->children,\n                                         window->parent->children->count - 1);\n\n                Window_update_title(window->parent->active_child);\n            } else {\n\n                window->parent->active_child = (Window*)0;\n            }\n        }\n\n        if(window->parent->over_child == window)\n            window->parent->over_child = (Window*)0;\n        \n        if(window->parent->drag_child == window)\n            window->parent->drag_child = (Window*)0;\n    }\n\n    Object_delete((Object*)window->context);\n    free(window);\n}\n\nvoid Window_resize(Window* window, int w, int h) {\n\n    window->width = w;\n    window->height = h;\n\n    Window_paint(window, (List*)0, 1);\n}"]}