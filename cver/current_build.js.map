{"version":3,"file":"../current_build.js","sources":["../platform/platformwrapper_emscripten.c","../wslib/object.c","../wslib/listnode.c","../wslib/styleutils.c","../wslib/list.c","../wslib/associativearray.c","../wslib/context.c","../wslib/desktop.c","../wslib/rect.c","../wslib/window.c","../core/module.c","../core/patchcore.c","../core/io.c","../platform/audiohandler.c","../core/unit.c","../uilib/frame.c","../uilib/menuentry.c","../widgets/sessionmenu.c","../uilib/slider.c","../units/masterout.c","../units/noise.c","../units/pitchknob.c","../units/sequence.c","../units/sine.c","../units/square.c","../widgets/patchdesktop.c","../uilib/menu.c","../main.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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A;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;A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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAPA;AAAA;AAAA;;;;AAWA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAQA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAA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","sourcesContent":["#include \"platformwrapper.h\"\r\n#include <emscripten.h>\r\n#include <stdlib.h>\r\n#include \"../wslib/list.h\"\r\n\r\nMouseCallback mouse_handler;\r\nResizeCallback resize_handler;\r\nContext* internal_context;\r\ndouble left_sum, right_sum;\r\nList* ah_list;\r\n\r\nvoid EMSCRIPTEN_KEEPALIVE doPullSample() {\r\n\r\n    int i;\r\n    double l, r;\r\n    AudioHandler* ah;\r\n\r\n    EM_ASM(\r\n        window.fo_sample[0] = window.fo_sample[1] = 0;\r\n    );\r\n\r\n    for(i = 0; i < ah_list->count; i++) {\r\n\r\n        ah = (AudioHandler*)List_get_at(ah_list, i);\r\n        ah->function(ah->parent_object, &l, &r);\r\n\r\n        EM_ASM_({\r\n            window.fo_sample[0] += $0;\r\n            window.fo_sample[1] += $1;\r\n        }, l, r);\r\n    }\r\n}\r\n\r\nvoid PlatformWrapper_init() {\r\n\r\n    ah_list = List_new();\r\n    internal_context = (Context*)0;\r\n    mouse_handler.param_object = (Object*)0;\r\n    mouse_handler.callback = (MouseCallback_handler)0;\r\n    resize_handler.param_object = (Object*)0;\r\n    resize_handler.callback = (ResizeCallback_handler)0;\r\n\r\n    //Set up the audio processing loop\r\n    EM_ASM(\r\n\r\n        window.fo_sample = [0, 0];\r\n\r\n        var audioCtx  = new (window.AudioContext || window.webkitAudioContext)(),\r\n            pcm_node  = audioCtx.createScriptProcessor(4096, 0, 2),\r\n            source    = audioCtx.createBufferSource();\r\n\r\n        pcm_node.onaudioprocess = function(e) {\r\n\r\n            var outbuf_l = e.outputBuffer.getChannelData(0),\r\n                outbuf_r = e.outputBuffer.getChannelData(1);\r\n    \r\n            for(var i = 0; i < 4096; i++) {\r\n                \r\n                Module.ccall('doPullSample');\r\n                outbuf_r[i] = window.fo_sample[1];\r\n                outbuf_l[i] = window.fo_sample[0];\r\n            }\r\n        };\r\n\r\n        source.connect(pcm_node);\r\n        pcm_node.connect(audioCtx.destination);\r\n        source.start();\r\n    );\r\n}\r\n\r\nvoid PlatformWrapper_hold_for_exit() {\r\n\r\n    return; //Emscripten doesn't like hang loops\r\n}\r\n\r\nvoid PlatformWrapper_install_audio_handler(AudioHandler* audio_handler) {\r\n\r\n    List_add(ah_list, (Object*)audio_handler);\r\n}\r\n\r\nint PlatformWrapper_is_mouse_shown() {\r\n\r\n    //Emscripten just uses the OS mouse\r\n    return 0;\r\n}\r\n\r\nContext* PlatformWrapper_get_context() {\r\n\r\n    //Init the display\r\n    //Declare our return variable\r\n    uint32_t *return_buffer = (uint32_t*)0;\r\n\r\n    //Clear the dimensions until we've gotten past any potential errors\r\n    uint16_t width = EM_ASM_INT({return window.innerWidth},0);\r\n    uint16_t height = EM_ASM_INT({return window.innerHeight},0);\r\n\r\n    //Attempt to create the framebuffer array \r\n    if(!(return_buffer = (uint32_t*)malloc(sizeof(uint32_t) * width * height)))\r\n        return (Context*)0; //Exit early indicating error with an empty pointer \r\n\r\n    //Clear the framebuffer to black\r\n    int i;\r\n    for(i = 0; i < width * height; i++)\r\n        return_buffer[i] = 0xFF000000; //The canvas *does* care about the opacity being set, which is annoying\r\n    \r\n    //Now we'll create the output canvas and insert it into the document\r\n    //(EM_ASM allows us to embed JS into our C)\r\n    //We will also se up the refresh timer here\r\n    EM_ASM_({ \r\n        \r\n        //Create and store canvas and information\r\n        window.fo_canvas = document.createElement('canvas');\r\n        document.body.style.margin = '0px';\r\n        window.fo_canvas.width = $0;\r\n        window.fo_canvas.height = $1;\r\n        window.fo_buf_address = $2;\r\n        window.fo_buf_size = 4 * $0 * $1;\r\n        document.body.appendChild(window.fo_canvas);\r\n        window.fo_context = window.fo_canvas.getContext('2d');\r\n        window.fo_canvas_data = window.fo_context.getImageData(0, 0, $0, $1);\r\n        window.fo_draw = true;\r\n\r\n        //Start refresh handler\r\n        setInterval(function() {\r\n\r\n            if(!window.fo_draw)\r\n                return;\r\n\r\n            //Create an unsigned byte subarray  \r\n            window.fo_canvas_data.data.set(\r\n                Module.HEAPU8.subarray(\r\n                    window.fo_buf_address, window.fo_buf_address + window.fo_buf_size\r\n                )\r\n            ); \r\n            window.fo_context.putImageData(window.fo_canvas_data, 0, 0);\r\n        }, 17);\r\n    }, width, height, return_buffer);\r\n\r\n    internal_context = Context_new(width, height, return_buffer);\r\n\r\n    return internal_context;\r\n}\r\n\r\nvoid EMSCRIPTEN_KEEPALIVE doMouseCallback(void) {\r\n\r\n    uint16_t mouse_x, mouse_y;\r\n    uint8_t buttons;\r\n\r\n    if(!mouse_handler.callback)\r\n        return;\r\n\r\n    //A mouse event has happened, so get the updated info \r\n    mouse_x = EM_ASM_INT({\r\n        return window.fo_mouse_x;\r\n    }, 0);\r\n\r\n    mouse_y = EM_ASM_INT({\r\n        return window.fo_mouse_y;\r\n    }, 0);\r\n\r\n    buttons = EM_ASM_INT({\r\n        return window.fo_button_status;\r\n    }, 0);\r\n\r\n    //Fire callback\r\n    mouse_handler.callback(mouse_handler.param_object, mouse_x, mouse_y, buttons);\r\n}\r\n\r\nvoid PlatformWrapper_install_mouse_callback(Object* param_object, MouseCallback_handler callback) {\r\n\r\n    //This is literally just here so that the function \r\n    //doesn't get optimized out\r\n    doMouseCallback();\r\n\r\n    EM_ASM(\r\n\r\n        //Attach status update function to the screen canvas\r\n        window.fo_button_status = 0;\r\n        window.fo_mouse_x = 0;\r\n        window.fo_mouse_y = 0;\r\n        window.fo_canvas.onmousemove = function(e) {\r\n            \r\n            window.fo_mouse_x = e.clientX;\r\n            window.fo_mouse_y = e.clientY;\r\n            Module.ccall('doMouseCallback');\r\n        };\r\n        window.fo_canvas.onmousedown = function(e) {\r\n\r\n            window.fo_button_status = 1;\r\n            Module.ccall('doMouseCallback');\r\n        };\r\n        window.fo_canvas.onmouseup = function(e) {\r\n\r\n            window.fo_button_status = 0;\r\n            Module.ccall('doMouseCallback');\r\n        };\r\n    );\r\n\r\n    mouse_handler.param_object = param_object;\r\n    mouse_handler.callback = callback;\r\n}\r\n\r\nvoid EMSCRIPTEN_KEEPALIVE doResizeCallback() {\r\n\r\n    uint16_t width = EM_ASM_INT({return window.innerWidth},0);\r\n    uint16_t height = EM_ASM_INT({return window.innerHeight},0);\r\n\r\n    free(internal_context->buffer);\r\n    internal_context->buffer = (uint32_t*)malloc(sizeof(uint32_t) * width * height);\r\n    internal_context->width = width;\r\n    internal_context->height = height;\r\n\r\n    EM_ASM_({\r\n        window.fo_buf_address = $0;\r\n        window.fo_buf_size = 4 * window.fo_canvas.width * window.fo_canvas.height;\r\n        window.fo_canvas_data = window.fo_context.getImageData(0, 0, window.fo_canvas.width, window.fo_canvas.height);\r\n        window.fo_draw = true;\r\n    }, internal_context->buffer);\r\n\r\n    resize_handler.callback(resize_handler.param_object, width, height);\r\n}\r\n\r\nvoid PlatformWrapper_install_resize_callback(Object* param_object, ResizeCallback_handler callback) {\r\n\r\n    EM_ASM(\r\n    \r\n        window.onresize = function() {\r\n\r\n            window.fo_draw = false;\r\n            window.fo_canvas.width = window.innerWidth;\r\n            window.fo_canvas.height = window.innerHeight;\r\n            Module.ccall('doResizeCallback');\r\n        };\r\n    );\r\n\r\n    resize_handler.param_object = param_object;\r\n    resize_handler.callback = callback;\r\n}","#include <stdlib.h>\r\n#include <string.h>\r\n#include \"object.h\"\r\n\r\nString* String_new(char* source_buf) {\r\n\r\n    int len, i;\r\n    String* string = (String*)malloc(sizeof(String));\r\n\r\n    if(!string)\r\n        return string;\r\n\r\n    Object_init((Object*)string, String_delete_function);\r\n    \r\n    if(!source_buf) {\r\n\r\n        string->buf = source_buf;\r\n        return string;\r\n    }\r\n\r\n    for(len = 1; source_buf[len-1]; len++);\r\n\r\n    if(!(string->buf = (char*)malloc(len))) {\r\n\r\n        Object_delete((Object*)string);\r\n        return (String*)0;\r\n    }\r\n\r\n    for(i = 0; i < len; i++)\r\n        string->buf[i] = source_buf[i];\r\n\r\n    return string;\r\n}\r\n\r\nint String_compare(String* string_a, String* string_b) {\r\n\r\n    return strcmp(string_a->buf, string_b->buf) == 0;\r\n}\r\n\r\nvoid String_delete_function(Object* string_object) {\r\n\r\n    if(!string_object)\r\n        return;\r\n\r\n    String* string = (String*)string_object;\r\n\r\n    if(string->buf)\r\n        free(string->buf);\r\n\r\n    Object_default_delete_function(string_object);\r\n}\r\n\r\nvoid Object_default_delete_function(Object* object) {\r\n\r\n    free((void*)object);\r\n}\r\n\r\nvoid Object_init(Object* object, DeleteFunction delete_function) {\r\n\r\n    if(delete_function)\r\n        object->delete_function = delete_function;\r\n    else\r\n        object->delete_function = Object_default_delete_function;\r\n}\r\n\r\nvoid Object_delete(Object* object) {\r\n\r\n    if(!object)\r\n        return;\r\n\r\n    if(object->delete_function)\r\n        object->delete_function(object);\r\n    else\r\n        Object_default_delete_function(object);\r\n}\r\n","#include <inttypes.h>\r\n#include <stdlib.h>\r\n#include \"listnode.h\"\r\n\r\n\r\n//================| ListNode Class Implementation |================//\r\n\r\n//Basic listnode constructor\r\nListNode* ListNode_new(Object* payload) {\r\n\r\n    //Malloc and/or fail null\r\n    ListNode* list_node;\r\n    if(!(list_node = (ListNode*)malloc(sizeof(ListNode))))\r\n        return list_node;\r\n\r\n    //Assign initial properties\r\n    Object_init((Object*)list_node, 0);\r\n    list_node->prev = (ListNode*)0;\r\n    list_node->next = (ListNode*)0;\r\n    list_node->payload = payload; \r\n\r\n    return list_node;\r\n}\r\n\r\n","\r\n#include \"styleutils.h\"\r\n\r\nvoid draw_panel(Context* context, int x, int y, int width, int height,\r\n               uint32_t color, int border_width, int invert) {\r\n\r\n    uint8_t r = RVAL(color);\r\n    uint8_t g = GVAL(color);\r\n    uint8_t b = BVAL(color);\r\n    uint32_t light_color = RGB(r > 155 ? 255 : r + 100, g > 155 ? 255 : g + 100, b > 155 ? 255 : b + 100);\r\n    uint32_t shade_color = RGB(r < 100 ? 0 : r - 100, g < 100 ? 0 : g - 100, b < 100 ? 0 : b - 100);\r\n    uint32_t temp;\r\n    int i;\r\n\r\n    if(invert) {\r\n\r\n        temp = shade_color;\r\n        shade_color = light_color;\r\n        light_color = temp;\r\n    }\r\n\r\n    for(i = 0; i < border_width; i++) {\r\n\r\n        //Top edge\r\n        Context_horizontal_line(context, x+i, y+i, width-(2*i), light_color);\r\n\r\n        //Left edge\r\n        Context_vertical_line(context, x+i, y+i+1, height-((i+1)*2), light_color);\r\n\r\n        //Bottom edge\r\n        Context_horizontal_line(context, x+i, (y+height)-(i+1), width-(2*i), shade_color);\r\n\r\n        //Right edge\r\n        Context_vertical_line(context, x+width-i-1, y+i+1, height-((i+1)*2), shade_color);\r\n    }\r\n}","#include <inttypes.h>\r\n#include <stdlib.h>\r\n#include \"list.h\"\r\n\r\n\r\n//================| ListNode Class Implementation |================//\r\n\r\n//Basic list constructor\r\nList* List_new() {\r\n    \r\n    //Malloc and/or fail null\r\n    List* list;\r\n    if(!(list = (List*)malloc(sizeof(List))))\r\n        return list;\r\n\r\n    //Fill in initial property values\r\n    //(All we know for now is that we start out with no items) \r\n    Object_init((Object*)list, List_delete);\r\n    list->count = 0;\r\n    list->root_node = (ListNode*)0;\r\n\r\n    return list;\r\n}\r\n\r\n//Insert a payload at the end of the list\r\n//Zero is fail, one is success\r\nint List_add(List* list, Object* payload) {\r\n\r\n    //Try to make a new node, exit early on fail \r\n    ListNode* new_node;\r\n    if(!(new_node = ListNode_new(payload))) \r\n        return 0;\r\n\r\n    //If there aren't any items in the list yet, assign the\r\n    //new item to the root node\r\n    if(!list->root_node) {\r\n \r\n        list->root_node = new_node;        \r\n    } else {\r\n\r\n        //Otherwise, we'll find the last node and add our new node after it\r\n        ListNode* current_node = list->root_node;\r\n\r\n        //Fast forward to the end of the list \r\n        while(current_node->next)\r\n            current_node = current_node->next;\r\n\r\n        //Make the last node and first node point to each other\r\n        current_node->next = new_node;\r\n        new_node->prev = current_node; \r\n    }\r\n\r\n    //Update the number of items in the list and return success\r\n    list->count++;\r\n\r\n    return 1;\r\n}\r\n\r\n//Get the payload of the list item at the given index\r\n//Indices are zero-based\r\nObject* List_get_at(List* list, unsigned int index) {\r\n\r\n    //If there's nothing in the list or we're requesting beyond the end of\r\n    //the list, return nothing\r\n    if(list->count == 0 || index >= list->count) \r\n        return (Object*)0;\r\n\r\n    //Iterate through the items in the list until we hit our index\r\n    ListNode* current_node = list->root_node;\r\n\r\n    //Iteration, making sure we don't hang on malformed lists\r\n    for(unsigned int current_index = 0; (current_index < index) && current_node; current_index++)\r\n        current_node = current_node->next;\r\n\r\n    //Return the payload, guarding against malformed lists\r\n    return current_node ? current_node->payload : (Object*)0;\r\n}\r\n\r\n//Remove the item at the specified index from the list and return the item that\r\n//was removed\r\n//Indices are zero-based\r\nObject* List_remove_at(List* list, unsigned int index) {\r\n\r\n    //This operates very similarly to List_get_at\r\n\r\n    Object* payload; \r\n\r\n    //Bounds check\r\n    if(list->count == 0 || index >= list->count) \r\n        return (Object*)0;\r\n\r\n    //Iterate through the items\r\n    ListNode* current_node = list->root_node;\r\n\r\n    for(unsigned int current_index = 0; (current_index < index) && current_node; current_index++)\r\n        current_node = current_node->next;\r\n\r\n    //This is where we differ from List_get_at by stashing the payload,\r\n    //re-pointing the current node's neighbors to each other and \r\n    //freeing the removed node \r\n\r\n    //Return early if we got a null node somehow\r\n    if(!current_node)\r\n        return (Object*)0;\r\n\r\n    //Stash the payload so we don't lose it when we delete the node     \r\n    payload =  current_node->payload;\r\n \r\n    //Re-point neighbors to each other \r\n    if(current_node->prev)\r\n        current_node->prev->next = current_node->next;\r\n\r\n    if(current_node->next)\r\n        current_node->next->prev = current_node->prev;\r\n\r\n    //If the item was the root item, we need to make\r\n    //the node following it the new root\r\n    if(index == 0)\r\n        list->root_node = current_node->next;\r\n\r\n    //Now that we've clipped the node out of the list, we must free its memory\r\n    Object_delete((Object*)current_node); \r\n\r\n    //Make sure the count of items is up-to-date\r\n    list->count--; \r\n\r\n    //Finally, return the payload\r\n    return payload;\r\n}\r\n\r\n//Delete a list as well as any items which it still contains\r\n//As such, shouldn't be used if there are any objects in the \r\n//list referenced elsewhere or else you'll have dangling pointer\r\n//issues\r\nvoid List_delete(Object* list_object) {\r\n\r\n    List* list = (List*)list_object;\r\n\r\n    if(!list_object)\r\n        return;\r\n\r\n    //Remove each item from the list and pass it to its deleter\r\n    while(list->count)\r\n        Object_delete(List_remove_at(list, 0));\r\n\r\n    //And delete the list itself\r\n    free(list);\r\n}","#include \"associativearray.h\"\r\n#include <stdlib.h>\r\n\r\nAssociativeArray* AssociativeArray_new() {\r\n\r\n    AssociativeArray* associative_array =\r\n        (AssociativeArray*)malloc(sizeof(AssociativeArray));\r\n\r\n    if(!associative_array)\r\n        return associative_array;\r\n\r\n    Object_init((Object*)associative_array, AssociativeArray_delete_function);\r\n    associative_array->keys = List_new();\r\n    associative_array->values = List_new();\r\n\r\n    if(!(associative_array->keys && associative_array->values)) {\r\n\r\n        Object_delete((Object*)associative_array);\r\n        return (AssociativeArray*)0;\r\n    }\r\n\r\n    return associative_array;\r\n}\r\n\r\nvoid AssociativeArray_delete_function(Object* associative_array_object) {\r\n\r\n    if(!associative_array_object)\r\n        return;\r\n\r\n    AssociativeArray* associative_array = \r\n        (AssociativeArray*)associative_array_object;\r\n\r\n    Object_delete((Object*)associative_array->keys);\r\n    Object_delete((Object*)associative_array->values);\r\n    Object_default_delete_function(associative_array_object);\r\n}\r\n\r\nObject* AssociativeArray_get(AssociativeArray* associative_array, String* key) {\r\n\r\n    int i;\r\n\r\n    for(i = 0; i < associative_array->keys->count; i++)\r\n        if(String_compare((String*)List_get_at(associative_array->keys, i), key))\r\n            break;\r\n\r\n    if(i == associative_array->keys->count)\r\n        return (Object*)0;\r\n\r\n    return List_get_at(associative_array->values, i);\r\n}\r\n\r\nint AssociativeArray_add(AssociativeArray* associative_array, String* key, Object* value) {\r\n\r\n    if(!List_add(associative_array->keys, (Object*)key))\r\n        return 0;\r\n    \r\n    return List_add(associative_array->values, value);\r\n}\r\n","#include <inttypes.h>\r\n#include \"context.h\"\r\n#include \"rect.h\"\r\n#include \"font.h\"\r\n\r\n\r\n//================| Context Class Implementation |================//\r\n\r\n//Constructor for our context\r\nContext* Context_new(uint16_t width, uint16_t height, uint32_t* buffer) {\r\n\r\n    static unsigned int handle_source = 0;\r\n\r\n    //Attempt to allocate\r\n    Context* context;\r\n    if(!(context = (Context*)malloc(sizeof(Context))))\r\n        return context; \r\n\r\n    //Init base object\r\n    Object_init((Object*)context, Context_delete_function);\r\n\r\n    //Attempt to allocate new rect list \r\n    if(!(context->clip_rects = List_new())) {\r\n\r\n        free(context);\r\n        return (Context*)0;\r\n    }\r\n\r\n    //Finish assignments\r\n    context->id = ++handle_source;\r\n    context->translate_x = 0;\r\n    context->translate_y = 0;\r\n    context->width = width; \r\n    context->height = height; \r\n    context->buffer = buffer;\r\n    context->clipping_on = 0;\r\n\r\n    return context;\r\n}\r\n\r\n//Clone from another context\r\nContext* Context_new_from(Context* source_context) {\r\n\r\n    return Context_new(source_context->width, source_context->height, source_context->buffer);\r\n}\r\n\r\nvoid Context_delete_function(Object* context_object) {\r\n\r\n    Context* context = (Context*)context_object;\r\n\r\n    if(!context_object)\r\n        return;\r\n\r\n    Object_delete((Object*)context->clip_rects);\r\n    free(context);\r\n}\r\n\r\nvoid Context_clipped_rect(Context* context, int x, int y, unsigned int width,\r\n                          unsigned int height, Rect* clip_area, uint32_t color) {\r\n\r\n    int cur_x;\r\n    int max_x = x + width;\r\n    int max_y = y + height;\r\n\r\n    //Translate the rectangle coordinates by the context translation values\r\n    x += context->translate_x;\r\n    y += context->translate_y;\r\n    max_x += context->translate_x;\r\n    max_y += context->translate_y;\r\n\r\n    //Make sure we don't go outside of the clip region:\r\n    if(x < clip_area->left)\r\n        x = clip_area->left;\r\n    \r\n    if(y < clip_area->top)\r\n        y = clip_area->top;\r\n\r\n    if(max_x > clip_area->right + 1)\r\n        max_x = clip_area->right + 1;\r\n\r\n    if(max_y > clip_area->bottom + 1)\r\n        max_y = clip_area->bottom + 1;\r\n\r\n    //Draw the rectangle into the framebuffer line-by line\r\n    //(bonus points if you write an assembly routine to do it faster)\r\n    for(; y < max_y; y++) \r\n        for(cur_x = x; cur_x < max_x; cur_x++) \r\n            context->buffer[y * context->width + cur_x] = color;\r\n}\r\n\r\n//Simple for-loop rectangle into a context\r\nvoid Context_fill_rect(Context* context, int x, int y,  \r\n                      unsigned int width, unsigned int height, uint32_t color) {\r\n\r\n    int max_x = x + width;\r\n    int max_y = y + height;\r\n    int i;\r\n    Rect* clip_area;\r\n    Rect screen_area;\r\n\r\n    //Fix from last time: Make sure we don't try to draw offscreen\r\n    if(max_x > context->width)\r\n        max_x = context->width;\r\n\r\n    if(max_y > context->height)\r\n        max_y = context->height;\r\n   \r\n    if(x < 0)\r\n        x = 0;\r\n    \r\n    if(y < 0)\r\n        y = 0;\r\n    \r\n    width = max_x - x;\r\n    height = max_y - y;    \r\n\r\n    //If there are clipping rects, draw the rect clipped to\r\n    //each of them. Otherwise, draw unclipped (clipped to the screen)\r\n    if(context->clip_rects->count) {\r\n       \r\n        for(i = 0; i < context->clip_rects->count; i++) {    \r\n\r\n            clip_area = (Rect*)List_get_at(context->clip_rects, i);\r\n            Context_clipped_rect(context, x, y, width, height, clip_area, color);\r\n        }\r\n    } else {\r\n\r\n        if(!context->clipping_on) {\r\n\r\n            screen_area.top = 0;\r\n            screen_area.left = 0;\r\n            screen_area.bottom = context->height - 1;\r\n            screen_area.right = context->width - 1;\r\n            Context_clipped_rect(context, x, y, width, height, &screen_area, color);\r\n        }\r\n    }\r\n}\r\n\r\n//A horizontal line as a filled rect of height 1\r\nvoid Context_horizontal_line(Context* context, int x, int y,\r\n                             unsigned int length, uint32_t color) {\r\n\r\n    Context_fill_rect(context, x, y, length, 1, color);\r\n}\r\n\r\n//A vertical line as a filled rect of width 1\r\nvoid Context_vertical_line(Context* context, int x, int y,\r\n                           unsigned int length, uint32_t color) {\r\n\r\n    Context_fill_rect(context, x, y, 1, length, color);\r\n}\r\n\r\n//Rectangle drawing using our horizontal and vertical lines\r\nvoid Context_draw_rect(Context* context, int x, int y, \r\n                       unsigned int width, unsigned int height, uint32_t color) {\r\n\r\n    Context_horizontal_line(context, x, y, width, color); //top\r\n    Context_vertical_line(context, x, y + 1, height - 2, color); //left \r\n    Context_horizontal_line(context, x, y + height - 1, width, color); //bottom\r\n    Context_vertical_line(context, x + width - 1, y + 1, height - 2, color); //right\r\n}\r\n\r\n//Update the clipping rectangles to only include those areas within both the\r\n//existing clipping region AND the passed Rect\r\nvoid Context_intersect_clip_rect(Context* context, Rect* rect) {\r\n\r\n    int i;\r\n    List* output_rects;\r\n    Rect* current_rect;\r\n    Rect* intersect_rect;\r\n \r\n    context->clipping_on = 1;\r\n\r\n    if(!(output_rects = List_new()))\r\n        return;\r\n\r\n    for(i = 0; i < context->clip_rects->count; i++) {\r\n\r\n        current_rect = (Rect*)List_get_at(context->clip_rects, i);\r\n        intersect_rect = Rect_intersect(current_rect, rect);\r\n\r\n        if(intersect_rect)\r\n            List_add(output_rects, (Object*)intersect_rect);\r\n    }\r\n\r\n    //Delete the original rectangle list\r\n    Object_delete((Object*)context->clip_rects);\r\n\r\n    //And re-point it to the new one we built above\r\n    context->clip_rects = output_rects;\r\n\r\n    //Free the input rect\r\n    Object_delete((Object*)rect);\r\n}\r\n\r\n//split all existing clip rectangles against the passed rect\r\nvoid Context_subtract_clip_rect(Context* context, Rect* subtracted_rect) {\r\n\r\n    //Check each item already in the list to see if it overlaps with\r\n    //the new rectangle\r\n    int i, j;\r\n    Rect* cur_rect;\r\n    List* split_rects;\r\n\r\n    context->clipping_on = 1;\r\n\r\n    for(i = 0; i < context->clip_rects->count; ) {\r\n\r\n        cur_rect = (Rect*)List_get_at(context->clip_rects, i);\r\n\r\n        //Standard rect intersect test (if no intersect, skip to next)\r\n        //see here for an example of why this works:\r\n        //http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other#tab-top\r\n        if(!(cur_rect->left <= subtracted_rect->right &&\r\n\t\t   cur_rect->right >= subtracted_rect->left &&\r\n\t\t   cur_rect->top <= subtracted_rect->bottom &&\r\n\t\t   cur_rect->bottom >= subtracted_rect->top)) {\r\n\r\n            i++;\r\n            continue;\r\n        }\r\n\r\n        //If this rectangle does intersect with the new rectangle, \r\n        //we need to split it\r\n        List_remove_at(context->clip_rects, i); //Original will be replaced w/splits\r\n        split_rects = Rect_split(cur_rect, subtracted_rect); //Do the split\r\n        Object_delete((Object*)cur_rect); //We can throw this away now, we're done with it\r\n\r\n        //Copy the split, non-overlapping result rectangles into the list \r\n        while(split_rects->count) {\r\n\r\n            cur_rect = (Rect*)List_remove_at(split_rects, 0);\r\n            List_add(context->clip_rects, (Object*)cur_rect);\r\n        }\r\n\r\n        //Free the empty split_rect list \r\n        Object_delete((Object*)split_rects);\r\n\r\n        //Since we removed an item from the list, we need to start counting over again \r\n        //In this way, we'll only exit this loop once nothing in the list overlaps \r\n        i = 0;    \r\n    }\r\n}\r\n\r\nvoid Context_add_clip_rect(Context* context, Rect* added_rect) {\r\n    \r\n    Context_subtract_clip_rect(context, added_rect);\r\n\r\n    //Now that we have made sure none of the existing rectangles overlap\r\n    //with the new rectangle, we can finally insert it \r\n    List_add(context->clip_rects, (Object*)added_rect);\r\n}\r\n\r\n//Remove all of the clipping rects from the passed context object\r\nvoid Context_clear_clip_rects(Context* context) {\r\n\r\n    Rect* cur_rect;\r\n\r\n    context->clipping_on = 0;\r\n\r\n    while(context->clip_rects->count)\r\n        Object_delete(List_remove_at(context->clip_rects, 0)); \r\n}\r\n\r\n//Draw a single character with the specified font color at the specified coordinates\r\nvoid Context_draw_char_clipped(Context* context, char character, int x, int y,\r\n                               uint32_t color, Rect* bound_rect) {\r\n\r\n    int font_x, font_y;\r\n    int off_x = 0;\r\n    int off_y = 0;\r\n    int count_x = 8; //Font is 8x12\r\n    int count_y = 12; \r\n    uint8_t shift_line;\r\n\r\n    //Make sure to take context translation into account\r\n    x += context->translate_x;\r\n    y += context->translate_y;\r\n\r\n    //Our font only handles the core set of 128 ASCII chars\r\n    character &= 0x7F;\r\n\r\n    //Check to see if the character is even inside of this rectangle\r\n    if(x > bound_rect->right || (x + 8) <= bound_rect->left ||\r\n       y > bound_rect->bottom || (y + 12) <= bound_rect->top)\r\n        return;\r\n\r\n    //Limit the drawn portion of the character to the interior of the rect\r\n    if(x < bound_rect->left)\r\n        off_x = bound_rect->left - x;        \r\n\r\n    if((x + 8) > bound_rect->right)\r\n        count_x = bound_rect->right - x + 1;\r\n\r\n    if(y < bound_rect->top)\r\n        off_y = bound_rect->top - y;\r\n\r\n    if((y + 12) > bound_rect->bottom)\r\n        count_y = bound_rect->bottom - y + 1;\r\n\r\n    //Now we do the actual pixel plotting loop\r\n    for(font_y = off_y; font_y < count_y; font_y++) {\r\n\r\n        //Capture the current line of the specified char\r\n        //Just a normal bmp[y * width + x], but in this\r\n        //case we're dealing with an array of 1bpp\r\n        //8-bit-wide character lines\r\n        shift_line = font_array[font_y * 128 + character];\r\n\r\n        //Pre-shift the line by the x-offset\r\n        shift_line <<= off_x;\r\n\r\n        for(font_x = off_x; font_x < count_x; font_x++) {\r\n\r\n            //Get the current leftmost bit of the current \r\n            //line of the character and, if it's set, plot a pixel\r\n            if(shift_line & 0x80)\r\n                context->buffer[(font_y + y) * context->width + (font_x + x)] = color;\r\n \r\n            //Shift in the next bit\r\n            shift_line <<= 1; \r\n        }\r\n    }\r\n}\r\n\r\n//This will be a lot like Context_fill_rect, but on a bitmap font character\r\nvoid Context_draw_char(Context* context, char character, int x, int y, uint32_t color) {\r\n\r\n    int i;\r\n    Rect* clip_area;\r\n    Rect screen_area;\r\n\r\n    //If there are clipping rects, draw the character clipped to\r\n    //each of them. Otherwise, draw unclipped (clipped to the screen)\r\n    if(context->clip_rects->count) {\r\n       \r\n        for(i = 0; i < context->clip_rects->count; i++) {    \r\n\r\n            clip_area = (Rect*)List_get_at(context->clip_rects, i);\r\n            Context_draw_char_clipped(context, character, x, y, color, clip_area);\r\n        }\r\n    } else {\r\n\r\n        if(!context->clipping_on) {\r\n\r\n            screen_area.top = 0;\r\n            screen_area.left = 0;\r\n            screen_area.bottom = context->height - 1;\r\n            screen_area.right = context->width - 1;\r\n            Context_draw_char_clipped(context, character, x, y, color, clip_area);\r\n        }\r\n    }\r\n}\r\n\r\n//Draw a line of text with the specified font color at the specified coordinates\r\nvoid Context_draw_text(Context* context, char* string, int x, int y, uint32_t color) {\r\n\r\n    for( ; *string; x += 8)\r\n        Context_draw_char(context, *(string++), x, y, color);\r\n}\r\n","#include <inttypes.h>\r\n#include <stdlib.h>\r\n#include \"desktop.h\"\r\n#include \"rect.h\"\r\n\r\n\r\n//================| Desktop Class Implementation |================//\r\n\r\n//Mouse image data\r\n#define CA 0xFF000000 //Black\r\n#define CB 0xFFFFFFFF //White\r\n#define CD 0x00000000 //Clear\r\n\r\nunsigned int mouse_img[MOUSE_BUFSZ] = {\r\n    CA, CD, CD, CD, CD, CD, CD, CD, CD, CD, CD,\r\n    CA, CA, CD, CD, CD, CD, CD, CD, CD, CD, CD,\r\n    CA, CB, CA, CD, CD, CD, CD, CD, CD, CD, CD,\r\n    CA, CB, CB, CA, CD, CD, CD, CD, CD, CD, CD,\r\n    CA, CB, CB, CB, CA, CD, CD ,CD, CD, CD, CD,\r\n    CA, CB, CB, CB, CB, CA, CD, CD, CD, CD, CD,\r\n    CA, CB, CB, CB, CB, CB, CA, CD, CD, CD, CD,\r\n    CA, CB, CB, CB, CB, CB, CB, CA, CD, CD, CD,\r\n    CA, CB, CB, CB, CB, CB, CB, CB, CA, CD, CD,\r\n    CA, CB, CB, CB, CB, CB, CB, CB, CB, CA, CD,\r\n    CA, CB, CB, CB, CB, CB, CB, CB, CB, CB, CA,\r\n    CA, CA, CA, CA, CB, CB, CB, CA, CA, CA, CA,\r\n    CD, CD, CD, CD, CA, CB, CB, CA, CD, CD, CD,\r\n    CD, CD, CD, CD, CA, CB, CB, CA, CD, CD, CD,\r\n    CD, CD, CD, CD, CD, CA, CB, CB, CA, CD, CD,\r\n    CD, CD, CD, CD, CD, CA, CB, CB, CA, CD, CD,\r\n    CD, CD, CD, CD, CD, CD, CA, CB, CA, CD, CD,\r\n    CD, CD, CD, CD, CD, CD, CD, CA, CA, CD, CD \r\n};\r\n\r\nDesktop* Desktop_new(Context* context) {\r\n\r\n    //Malloc or fail \r\n    Desktop* desktop;\r\n    if(!(desktop = (Desktop*)malloc(sizeof(Desktop))))\r\n        return desktop;\r\n\r\n    if(!Desktop_init(desktop, context)) {\r\n\r\n        Object_delete((Object*)desktop);\r\n        return (Desktop*)0;\r\n    }\r\n\r\n    return desktop;\r\n}\r\n\r\nint Desktop_init(Desktop* desktop, Context* context) {\r\n\r\n    //Initialize the Window bits of our desktop\r\n    if(!Window_init((Window*)desktop, 0, 0, context->width, context->height,\r\n                    WIN_NODECORATION | WIN_NORAISE, context))\r\n        return 0;\r\n\r\n    //Override our paint function\r\n    desktop->window.paint_function = Desktop_paint_handler;\r\n\r\n    //Now continue by filling out the desktop-unique properties \r\n    desktop->window.last_button_state = 0;\r\n\r\n    //Init mouse to the center of the screen\r\n    desktop->mouse_x = desktop->window.context->width / 2;\r\n    desktop->mouse_y = desktop->window.context->height / 2;\r\n    desktop->mouse_shown = 1;\r\n\r\n    //Make sure the mouse always starts over the desktop\r\n    Window_mouseover((Window*)desktop);\r\n\r\n    return 1;\r\n}\r\n\r\n//Paint the desktop \r\nvoid Desktop_paint_handler(Window* desktop_window) {\r\n  \r\n    //Fill the desktop\r\n    Context_fill_rect(desktop_window->context, 0, 0, desktop_window->context->width, desktop_window->context->height, RGB(11, 162, 193));\r\n\r\n    //Draw some test text\r\n    Context_draw_text(desktop_window->context, \"Windowing Systems by Example\",\r\n                      0, desktop_window->height - 12, 0xFFFFFFFF);\r\n}\r\n\r\n//Our overload of the Window_process_mouse function used to capture the screen mouse position \r\nvoid Desktop_process_mouse(Desktop* desktop, uint16_t mouse_x,\r\n                           uint16_t mouse_y, uint8_t mouse_buttons) {\r\n\r\n    int i, x, y;\r\n    Window* child;\r\n    List* dirty_list;\r\n    Rect* mouse_rect;\r\n\r\n    //Do the old generic mouse handling\r\n    Window_process_mouse((Window*)desktop, mouse_x, mouse_y, mouse_buttons);\r\n\r\n    //Window painting now happens inside of the window raise and move operations\r\n    \r\n    //Exit early if the mouse is turned off\r\n    if(!desktop->mouse_shown)\r\n        return;\r\n\r\n    //Build a dirty rect list for the mouse area\r\n    if(!(dirty_list = List_new()))\r\n        return;\r\n\r\n    if(!(mouse_rect = Rect_new(desktop->mouse_y, desktop->mouse_x, \r\n                               desktop->mouse_y + MOUSE_HEIGHT - 1,\r\n                               desktop->mouse_x + MOUSE_WIDTH - 1))) {\r\n\r\n        free(dirty_list);\r\n        return;\r\n    }\r\n\r\n    List_add(dirty_list, (Object*)mouse_rect);\r\n\r\n    //Do a dirty update for the desktop, which will, in turn, do a \r\n    //dirty update for all affected child windows\r\n    Window_paint((Window*)desktop, dirty_list, 1); \r\n\r\n    //Clean up mouse dirty list\r\n    List_remove_at(dirty_list, 0);\r\n    free(dirty_list);\r\n    free(mouse_rect);\r\n\r\n    //Update mouse position\r\n    desktop->mouse_x = mouse_x;\r\n    desktop->mouse_y = mouse_y;\r\n\r\n    //No more hacky mouse, instead we're going to rather inefficiently \r\n    //copy the pixels from our mouse image into the framebuffer\r\n    for(y = 0; y < MOUSE_HEIGHT; y++) {\r\n\r\n        //Make sure we don't draw off the bottom of the screen\r\n        if((y + mouse_y) >= desktop->window.context->height)\r\n            break;\r\n\r\n        for(x = 0; x < MOUSE_WIDTH; x++) {\r\n\r\n            //Make sure we don't draw off the right side of the screen\r\n            if((x + mouse_x) >= desktop->window.context->width)\r\n                break;\r\n \r\n            //Don't place a pixel if it's transparent (still going off of ABGR here,\r\n            //change to suit your palette)\r\n            if(mouse_img[y * MOUSE_WIDTH + x] & 0xFF000000)\r\n                desktop->window.context->buffer[(y + mouse_y)\r\n                                                * desktop->window.context->width \r\n                                                + (x + mouse_x)\r\n                                               ] = mouse_img[y * MOUSE_WIDTH + x];\r\n        }\r\n    }\r\n}\r\n","#include \"rect.h\"\r\n\r\n//================| Rect Class Implementation |================//\r\n\r\n//Allocate a new rectangle object\r\nRect* Rect_new(int top, int left, int bottom, int right) {\r\n\r\n    //Attempt to allocate the object\r\n    Rect* rect;\r\n    if(!(rect = (Rect*)malloc(sizeof(Rect))))\r\n        return rect;\r\n\r\n    //Assign intial values\r\n    Object_init((Object*)rect, 0);\r\n    rect->top = top;\r\n    rect->left = left;\r\n    rect->bottom = bottom;\r\n    rect->right = right;\r\n\r\n    return rect;\r\n}\r\n\r\n//Explode subject_rect into a list of contiguous rects which are\r\n//not occluded by cutting_rect\r\n// ________                ____ ___\r\n//|s    ___|____          |o   |o__|\r\n//|____|___|   c|   --->  |____|          \r\n//     |________|              \r\nList* Rect_split(Rect* subject_rect, Rect* cutting_rect) {\r\n\r\n    //Allocate the list of result rectangles\r\n    List* output_rects;\r\n    if(!(output_rects = List_new()))\r\n        return output_rects;\r\n\r\n    //We're going to modify the subject rect as we go,\r\n    //so we'll clone it so as to not upset the object \r\n    //we were passed\r\n    Rect subject_copy;\r\n    subject_copy.top = subject_rect->top;\r\n    subject_copy.left = subject_rect->left;\r\n    subject_copy.bottom = subject_rect->bottom;\r\n    subject_copy.right = subject_rect->right;\r\n\r\n    //We need a rectangle to hold new rectangles before\r\n    //they get pushed into the output list\r\n    Rect* temp_rect;\r\n\r\n    //Begin splitting\r\n    //1 -Split by left edge if that edge is between the subject's left and right edges \r\n    if(cutting_rect->left > subject_copy.left && cutting_rect->left <= subject_copy.right) {\r\n\r\n        //Try to make a new rectangle spanning from the subject rectangle's left and stopping before \r\n        //the cutting rectangle's left\r\n        if(!(temp_rect = Rect_new(subject_copy.top, subject_copy.left,\r\n                                  subject_copy.bottom, cutting_rect->left - 1))) {\r\n\r\n            //If the object creation failed, we need to delete the list and exit failed\r\n            free(output_rects);\r\n\r\n            return (List*)0;\r\n        }\r\n\r\n        //Add the new rectangle to the output list\r\n        List_add(output_rects, (Object*)temp_rect);\r\n\r\n        //Shrink the subject rectangle to exclude the split portion\r\n        subject_copy.left = cutting_rect->left;\r\n    }\r\n\r\n    //2 -Split by top edge if that edge is between the subject's top and bottom edges \r\n    if(cutting_rect->top > subject_copy.top && cutting_rect->top <= subject_copy.bottom) {\r\n\r\n        //Try to make a new rectangle spanning from the subject rectangle's top and stopping before \r\n        //the cutting rectangle's top\r\n        if(!(temp_rect = Rect_new(subject_copy.top, subject_copy.left,\r\n                                  cutting_rect->top - 1, subject_copy.right))) {\r\n\r\n            //If the object creation failed, we need to delete the list and exit failed\r\n            //This time, also delete any previously allocated rectangles\r\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\r\n                free(temp_rect);\r\n\r\n            free(output_rects);\r\n\r\n            return (List*)0;\r\n        }\r\n\r\n        //Add the new rectangle to the output list\r\n        List_add(output_rects, (Object*)temp_rect);\r\n\r\n        //Shrink the subject rectangle to exclude the split portion\r\n        subject_copy.top = cutting_rect->top;\r\n    }\r\n\r\n    //3 -Split by right edge if that edge is between the subject's left and right edges \r\n    if(cutting_rect->right >= subject_copy.left && cutting_rect->right < subject_copy.right) {\r\n\r\n        //Try to make a new rectangle spanning from the subject rectangle's right and stopping before \r\n        //the cutting rectangle's right\r\n        if(!(temp_rect = Rect_new(subject_copy.top, cutting_rect->right + 1,\r\n                                  subject_copy.bottom, subject_copy.right))) {\r\n\r\n            //Free on fail\r\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\r\n                free(temp_rect);\r\n\r\n            free(output_rects);\r\n\r\n            return (List*)0;\r\n        }\r\n\r\n        //Add the new rectangle to the output list\r\n        List_add(output_rects, (Object*)temp_rect);\r\n\r\n        //Shrink the subject rectangle to exclude the split portion\r\n        subject_copy.right = cutting_rect->right;\r\n    }\r\n\r\n    //4 -Split by bottom edge if that edge is between the subject's top and bottom edges \r\n    if(cutting_rect->bottom >= subject_copy.top && cutting_rect->bottom < subject_copy.bottom) {\r\n\r\n        //Try to make a new rectangle spanning from the subject rectangle's bottom and stopping before \r\n        //the cutting rectangle's bottom\r\n        if(!(temp_rect = Rect_new(cutting_rect->bottom + 1, subject_copy.left,\r\n                                  subject_copy.bottom, subject_copy.right))) {\r\n\r\n            //Free on fail\r\n            for(; output_rects->count; temp_rect = (Rect*)List_remove_at(output_rects, 0))\r\n                free(temp_rect);\r\n\r\n            free(output_rects);\r\n\r\n            return (List*)0;\r\n        }\r\n\r\n        //Add the new rectangle to the output list\r\n        List_add(output_rects, (Object*)temp_rect);\r\n\r\n        //Shrink the subject rectangle to exclude the split portion\r\n        subject_copy.bottom = cutting_rect->bottom;\r\n    }\r\n \r\n    //Finally, after all that, we can return the output rectangles \r\n    return output_rects;\r\n}\r\n\r\nRect* Rect_intersect(Rect* rect_a, Rect* rect_b) {\r\n\r\n    Rect* result_rect;\r\n\r\n    if(!(rect_a->left <= rect_b->right &&\r\n\t   rect_a->right >= rect_b->left &&\r\n\t   rect_a->top <= rect_b->bottom &&\r\n\t   rect_a->bottom >= rect_b->top))\r\n        return (Rect*)0;\r\n\r\n    if(!(result_rect = Rect_new(rect_a->top, rect_a->left,\r\n                                rect_a->bottom, rect_a->right)))\r\n        return (Rect*)0;\r\n\r\n    if(rect_b->left > result_rect->left && rect_b->left <= result_rect->right) \r\n        result_rect->left = rect_b->left;\r\n \r\n    if(rect_b->top > result_rect->top && rect_b->top <= result_rect->bottom) \r\n        result_rect->top = rect_b->top;\r\n\r\n    if(rect_b->right >= result_rect->left && rect_b->right < result_rect->right)\r\n        result_rect->right = rect_b->right;\r\n\r\n    if(rect_b->bottom >= result_rect->top && rect_b->bottom < result_rect->bottom)\r\n        result_rect->bottom = rect_b->bottom;\r\n\r\n    return result_rect;\r\n}\r\n","#include <inttypes.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include \"window.h\"\r\n#include \"styleutils.h\"\r\n\r\n\r\n//================| Window Class Implementation |================//\r\n\r\n//Here's a quick, crappy pseudo-RNG since you probably don't have one\r\nuint8_t pseudo_rand_8() {\r\n\r\n    static uint16_t seed = 0;\r\n    return (uint8_t)(seed = (12657 * seed + 12345) % 256);\r\n}\r\n\r\nvoid print_window(Window* window) {\r\n\r\n    printf(\"\\n-----------------\\nNEW WINDOW\\n-----------------\\n\");\r\n    printf(\"Object deleter #: %p\\n\", (void*)window->object.delete_function);\r\n    printf(\"Parent pointer: 0x%08X\\n\", (int)window->parent);\r\n    printf(\"Window ID: %i\\n\", window->id);\r\n    printf(\"Window position: (%i, %i)\\n\", window->x, window->y);\r\n    printf(\"Window dimensions: %i x %i\\n\", window->width, window->height);\r\n    printf(\"Window flags: 0x%04X\\n\", window->flags);\r\n    printf(\"Context pointer: 0x%08X\\n\", (int)window->context);\r\n    printf(\"Drag child pointer: 0x%08X\\n\", (int)window->drag_child);\r\n    printf(\"Active child pointer: 0x%08X\\n\", (int)window->active_child);\r\n    printf(\"Over child pointer: 0x%08X\\n\", (int)window->over_child);\r\n    printf(\"Child list pointer: 0x%08X\\n\", (int)window->children);\r\n    printf(\"Drag offsets: (%i, %i)\\n\", window->drag_off_x, window->drag_off_y);\r\n    printf(\"Last button state: 0x%02X\\n\", window->last_button_state);\r\n    printf(\"Click cycle: %i\\n\", window->click_cycle);\r\n    printf(\"Paint function #: %p\\n\", (void*)window->paint_function);\r\n    printf(\"Mousedown function #: %p\\n\", (void*)window->mousedown_function);\r\n    printf(\"Mouseup function #: %p\\n\", (void*)window->mouseup_function);\r\n    printf(\"Mouseover function #: %p\\n\", (void*)window->mouseover_function);\r\n    printf(\"Mouseout function #: %p\\n\", (void*)window->mouseout_function);\r\n    printf(\"Mousemove function #: %p\\n\", (void*)window->mousemove_function);\r\n    printf(\"Mouseclick function #: %p\\n\", (void*)window->mouseclick_function);\r\n    printf(\"Move function #: %p\\n\", (void*)window->move_function);\r\n    if(window->title)\r\n        printf(\"Window title: %s\\n\", window->title);\r\n    else\r\n        printf(\"Window title:\\n\");\r\n}\r\n\r\n//Window constructor\r\nWindow* Window_new(int16_t x, int16_t y, uint16_t width,\r\n                   uint16_t height, uint16_t flags, Context* context) {\r\n\r\n    //Try to allocate space for a new WindowObj and fail through if malloc fails\r\n    Window* window;\r\n    if(!(window = (Window*)malloc(sizeof(Window))))\r\n        return window;\r\n\r\n    //Attempt to initialize the new window\r\n    if(!Window_init(window, x, y, width, height, flags, context)) {\r\n    \r\n        free(window);\r\n        return (Window*)0;\r\n    }\r\n\r\n    return window;\r\n}\r\n\r\n//Seperate object allocation from initialization so we can implement\r\n//our inheritance scheme\r\nint Window_init(Window* window, int16_t x, int16_t y, uint16_t width,\r\n                uint16_t height, uint16_t flags, Context* context) {\r\n\r\n    static unsigned int handle_source = 0;\r\n\r\n    Object_init((Object*)window, Window_delete_function);\r\n\r\n    //Moved over here from the desktop \r\n    //Create child list or clean up and fail\r\n    if(!(window->children = List_new()))\r\n        return 0;\r\n\r\n    //Assign the property values\r\n    window->id = ++handle_source;\r\n    window->x = x;\r\n    window->y = y;\r\n    window->width = width;\r\n    window->height = height;\r\n    window->context = context ? Context_new_from(context) : context;\r\n    window->flags = flags;\r\n    window->parent = (Window*)0;\r\n    window->drag_child = (Window*)0;\r\n    window->drag_off_x = 0;\r\n    window->drag_off_y = 0;\r\n    window->last_button_state = 0;\r\n    window->click_cycle = 0;\r\n    window->paint_function = Window_paint_handler;\r\n    window->mousedown_function = (WindowMousedownHandler)0;\r\n    window->mouseup_function = (WindowMouseupHandler)0;\r\n    window->mouseover_function = (WindowMouseoverHandler)0;\r\n    window->mouseout_function = (WindowMouseoutHandler)0;\r\n    window->mousemove_function = (WindowMousemoveHandler)0;\r\n    window->mouseclick_function = (WindowMouseclickHandler)0;\r\n    window->move_function = Window_move_function;\r\n    window->active_child = (Window*)0;\r\n    window->over_child = (Window*)0;\r\n    window->title = (char*)0;\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Window_mousedown(Window* window, int x, int y) {\r\n\r\n    if(window->click_cycle != 2) \r\n        return;\r\n\r\n    window->click_cycle = 3;\r\n\r\n    if(window->mousedown_function)\r\n        window->mousedown_function(window, x, y);\r\n}\r\n\r\nvoid Window_mouseup(Window* window, int x, int y) {\r\n\r\n    if(window->mouseup_function)\r\n        window->mouseup_function(window, x, y);\r\n\r\n    if(window->click_cycle == 3)\r\n        Window_mouseclick(window, x, y);\r\n\r\n    window->click_cycle = 1;\r\n}\r\n\r\nvoid Window_mouseover(Window* window) {\r\n\r\n    window->click_cycle = 1;\r\n\r\n    if(window->mouseover_function)\r\n        window->mouseover_function(window);\r\n}\r\n\r\nvoid Window_mouseout(Window* window) {\r\n\r\n    int old_click_cycle = window->click_cycle;\r\n\r\n    window->click_cycle = 0;\r\n\r\n    if(old_click_cycle == 3)\r\n        Window_mouseup(window, 0, 0);\r\n\r\n    if(window->over_child) {\r\n\r\n        Window_mouseout(window->over_child);\r\n        window->over_child = (Window*)0;\r\n    }\r\n\r\n    if(window->mouseout_function)\r\n        window->mouseout_function(window);    \r\n}\r\n\r\nvoid Window_mousemove(Window* window, int x, int y) {\r\n\r\n    if(window->mousemove_function)\r\n        window->mousemove_function(window, x, y);\r\n}\r\n\r\nvoid Window_mouseclick(Window* window, int x, int y) {\r\n\r\n    if(window->mouseclick_function)\r\n        window->mouseclick_function(window, x, y);\r\n}\r\n\r\n//Recursively get the absolute on-screen x-coordinate of this window\r\nint Window_screen_x(Window* window) {\r\n\r\n    if(window->parent)\r\n        return window->x + Window_screen_x(window->parent);\r\n    \r\n    return window->x;\r\n}\r\n\r\n//Recursively get the absolute on-screen y-coordinate of this window\r\nint Window_screen_y(Window* window) {\r\n\r\n    if(window->parent)\r\n        return window->y + Window_screen_y(window->parent);\r\n    \r\n    return window->y;\r\n}\r\n\r\nvoid Window_draw_border(Window* window) {\r\n\r\n    uint32_t tb_color;\r\n    int screen_x = Window_screen_x(window);\r\n    int screen_y = Window_screen_y(window);\r\n    \r\n    //Outer border\r\n    draw_panel(window->context, screen_x, screen_y, window->width,\r\n               window->height, WIN_BGCOLOR, 1, 0);\r\n    \r\n    //Title border\r\n    draw_panel(window->context, screen_x+3, screen_y+3, window->width - 6,\r\n               22, WIN_BGCOLOR, 1, 1);\r\n    \r\n    //Body border\r\n    draw_panel(window->context, screen_x+3, screen_y+27, window->width - 6,\r\n               window->height - 30, WIN_BGCOLOR, 1, 1);\r\n    \r\n    //Left frame\r\n    Context_fill_rect(window->context, screen_x+1, screen_y+1, 2, \r\n                      window->height - 2, WIN_BGCOLOR); \r\n    \r\n    //Right frame\r\n    Context_fill_rect(window->context, screen_x + window->width - 3,\r\n                      screen_y + 1, 2, window->height - 2, WIN_BGCOLOR); \r\n    \r\n    //Top frame\r\n    Context_fill_rect(window->context, screen_x + 3, screen_y + 1,\r\n                      window->width - 6, 2, WIN_BGCOLOR); \r\n    \r\n    //Mid frame\r\n    Context_fill_rect(window->context, screen_x + 3, screen_y + 25,\r\n                      window->width - 6, 2, WIN_BGCOLOR); \r\n    \r\n    //Bottom frame\r\n    Context_fill_rect(window->context, screen_x + 3, screen_y + window->height - 3,\r\n                      window->width - 6, 2, WIN_BGCOLOR); \r\n        \r\n    //Button\r\n    draw_panel(window->context, screen_x + window->width - 24, screen_y + 4,\r\n               20, 20, WIN_BGCOLOR, 1, 0);\r\n    Context_fill_rect(window->context, screen_x + window->width - 23,\r\n                      screen_y + 5, 18, 18, WIN_BGCOLOR); \r\n    \r\n    //Titlebar\r\n    if(window->parent->active_child == window)\r\n        tb_color = RGB(182, 0, 0);\r\n    else \r\n        tb_color = RGB(238, 203, 137);\r\n    \r\n    Context_fill_rect(window->context, screen_x + 4, screen_y + 4,\r\n                      window->width - 28, 20, tb_color);\r\n\r\n    //Draw the window title\r\n    Context_draw_text(window->context, window->title, (WIN_TITLEHEIGHT / 2) + screen_x - 6,\r\n                      (WIN_TITLEHEIGHT / 2) + screen_y - 6,\r\n                      window->parent->active_child == window ? \r\n                          WIN_TEXTCOLOR : WIN_TEXTCOLOR_INACTIVE);\r\n\r\n}\r\n\r\n//Apply clipping for window bounds without subtracting child window rects\r\nvoid Window_apply_bound_clipping(Window* window, Context* context, int in_recursion, List* dirty_regions) {\r\n\r\n    Rect *temp_rect, *current_dirty_rect, *clone_dirty_rect;\r\n    int screen_x, screen_y, i;\r\n    List* clip_windows;\r\n    Window* clipping_window;\r\n\r\n    //Can't do this without a context\r\n    if(!context)\r\n        return;\r\n\r\n    //Build the visibility rectangle for this window\r\n    //If the window is decorated and we're recursing, we want to limit\r\n    //the window's drawable area to the area inside the window decoration.\r\n    //If we're not recursing, however, it means we're about to paint \r\n    //ourself and therefore we want to wait until we've finished painting\r\n    //the window border to shrink the clipping area \r\n    screen_x = Window_screen_x(window);\r\n    screen_y = Window_screen_y(window);\r\n    \r\n    if((!(window->flags & WIN_NODECORATION)) && in_recursion) {\r\n\r\n        //Limit client drawable area \r\n        screen_x += WIN_BORDERWIDTH;\r\n        screen_y += WIN_TITLEHEIGHT;\r\n        temp_rect = Rect_new(screen_y, screen_x,\r\n                             screen_y + window->height - WIN_TITLEHEIGHT - WIN_BORDERWIDTH - 1, \r\n                             screen_x + window->width - (2*WIN_BORDERWIDTH) - 1);\r\n    } else {\r\n\r\n        temp_rect = Rect_new(screen_y, screen_x, screen_y + window->height - 1, \r\n                             screen_x + window->width - 1);\r\n    }\r\n\r\n    //If there's no parent (meaning we're at the top of the window tree)\r\n    //then we just add our rectangle and exit\r\n    //Here's our change: If we were passed a dirty region list, we first\r\n    //clone those dirty rects into the clipping region and then intersect\r\n    //the top-level window bounds against it so that we're limited to the\r\n    //dirty region from the outset\r\n    if(!window->parent) {\r\n\r\n        if(dirty_regions) {\r\n\r\n            //Clone the dirty regions and put them into the clipping list\r\n            for(i = 0; i < dirty_regions->count; i++) {\r\n            \r\n                //Clone\r\n                current_dirty_rect = (Rect*)List_get_at(dirty_regions, i);\r\n                clone_dirty_rect = Rect_new(current_dirty_rect->top,\r\n                                            current_dirty_rect->left,\r\n                                            current_dirty_rect->bottom,\r\n                                            current_dirty_rect->right);\r\n                \r\n                //Add\r\n                Context_add_clip_rect(context, clone_dirty_rect);\r\n            }\r\n\r\n            //Finally, intersect this top level window against them\r\n            Context_intersect_clip_rect(context, temp_rect);\r\n\r\n        } else {\r\n\r\n            Context_add_clip_rect(context, temp_rect);\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    //Otherwise, we first reduce our clipping area to the visibility area of our parent\r\n    Window_apply_bound_clipping(window->parent, context, 1, dirty_regions);\r\n\r\n    //Now that we've reduced our clipping area to our parent's clipping area, we can\r\n    //intersect our own bounds rectangle to get our main visible area  \r\n    Context_intersect_clip_rect(context, temp_rect);\r\n\r\n    //And finally, we subtract the rectangles of any siblings that are occluding us \r\n    clip_windows = Window_get_windows_above(window->parent, window);\r\n\r\n    while(clip_windows->count) {\r\n        \r\n        clipping_window = (Window*)List_remove_at(clip_windows, 0);\r\n\r\n        //Get a rectangle from the window, subtract it from the clipping \r\n        //region, and dispose of it\r\n        screen_x = Window_screen_x(clipping_window);\r\n        screen_y = Window_screen_y(clipping_window);\r\n\r\n        temp_rect = Rect_new(screen_y, screen_x,\r\n                             screen_y + clipping_window->height - 1,\r\n                             screen_x + clipping_window->width - 1);\r\n        Context_subtract_clip_rect(context, temp_rect);\r\n        Object_delete((Object*)(Object*)temp_rect);\r\n    }\r\n\r\n    //Dispose of the used-up list \r\n    Object_delete((Object*)clip_windows);\r\n}\r\n\r\nvoid Window_update_title(Window* window) {\r\n\r\n    int screen_x, screen_y;\r\n\r\n    if(!window->context || \r\n       (window->flags & WIN_HIDDEN) ||\r\n       (window->flags & WIN_NODECORATION))\r\n        return;\r\n\r\n    //Start by limiting painting to the window's visible area\r\n    Window_apply_bound_clipping(window, window->context, 0, (List*)0);\r\n\r\n    //Draw border\r\n    Window_draw_border(window);\r\n\r\n    Context_clear_clip_rects(window->context);\r\n}\r\n\r\n//Request a repaint of a certain region of a window\r\nvoid Window_invalidate(Window* window, int top, int left, int bottom, int right) {\r\n\r\n    List* dirty_regions;\r\n    Rect* dirty_rect;\r\n\r\n    //This function takes coordinates in terms of window coordinates\r\n    //So we need to convert them to screen space \r\n    int origin_x = Window_screen_x(window);\r\n    int origin_y = Window_screen_y(window);\r\n    top += origin_y;\r\n    bottom += origin_y;\r\n    left += origin_x;\r\n    right += origin_x;\r\n    \r\n    //Attempt to create a new dirty rect list \r\n    if(!(dirty_regions = List_new()))\r\n        return;\r\n\r\n    if(!(dirty_rect = Rect_new(top, left, bottom, right))) {\r\n\r\n        Object_delete((Object*)dirty_regions);\r\n        return;\r\n    }\r\n\r\n    if(!List_add(dirty_regions, (Object*)dirty_rect)) {\r\n\r\n        Object_delete((Object*)dirty_regions);\r\n        return;\r\n    }\r\n\r\n    Window_paint(window, dirty_regions, 0);\r\n\r\n    //Clean up the dirty rect list\r\n    Object_delete((Object*)dirty_regions);\r\n}\r\n\r\n//Another override-redirect function\r\nvoid Window_paint(Window* window, List* dirty_regions, uint8_t paint_children) {\r\n\r\n    int i, j, screen_x, screen_y, child_screen_x, child_screen_y;\r\n    Window* current_child;\r\n    Rect* temp_rect;\r\n\r\n    //Can't paint without a context\r\n    if(!window->context || (window->flags & WIN_HIDDEN))\r\n        return;\r\n\r\n    //Start by limiting painting to the window's visible area\r\n    Window_apply_bound_clipping(window, window->context, 0, dirty_regions);\r\n\r\n    //Set the context translation\r\n    screen_x = Window_screen_x(window);\r\n    screen_y = Window_screen_y(window);\r\n\r\n    //If we have window decorations turned on, draw them and then further\r\n    //limit the clipping area to the inner drawable area of the window \r\n    if(!(window->flags & WIN_NODECORATION)) {\r\n\r\n        //Draw border\r\n        Window_draw_border(window);\r\n\r\n        //Limit client drawable area \r\n        screen_x += WIN_BORDERWIDTH;\r\n        screen_y += WIN_TITLEHEIGHT;\r\n        temp_rect = Rect_new(screen_y, screen_x,\r\n                             screen_y + window->height - WIN_TITLEHEIGHT - WIN_BORDERWIDTH - 1, \r\n                             screen_x + window->width - (2*WIN_BORDERWIDTH) - 1);\r\n        Context_intersect_clip_rect(window->context, temp_rect);\r\n    }\r\n\r\n    //Then subtract the screen rectangles of any children \r\n    //NOTE: We don't do this in Window_apply_bound_clipping because, due to \r\n    //its recursive nature, it would cause the screen rectangles of all of \r\n    //our parent's children to be subtracted from the clipping area -- which\r\n    //would eliminate this window. \r\n    for(i = 0; i < window->children->count; i++) {\r\n\r\n        current_child = (Window*)List_get_at(window->children, i);\r\n\r\n        if(current_child->flags & WIN_HIDDEN)\r\n            continue;\r\n\r\n        child_screen_x = Window_screen_x(current_child);\r\n        child_screen_y = Window_screen_y(current_child);\r\n\r\n        temp_rect = Rect_new(child_screen_y, child_screen_x,\r\n                             child_screen_y + current_child->height - 1,\r\n                             child_screen_x + current_child->width - 1);\r\n        Context_subtract_clip_rect(window->context, temp_rect);\r\n        Object_delete((Object*)temp_rect);\r\n    }\r\n\r\n    //Finally, with all the clipping set up, we can set the context's 0,0 to the top-left corner\r\n    //of the window's drawable area, and call the window's final paint function \r\n    window->context->translate_x = screen_x;\r\n    window->context->translate_y = screen_y;\r\n    window->paint_function(window);\r\n\r\n    //Now that we're done drawing this window, we can clear the changes we made to the context\r\n    Context_clear_clip_rects(window->context);\r\n    window->context->translate_x = 0;\r\n    window->context->translate_y = 0;\r\n    \r\n    //Even though we're no longer having all mouse events cause a redraw from the desktop\r\n    //down, we still need to call paint on our children in the case that we were called with\r\n    //a dirty region list since each window needs to be responsible for recursively checking\r\n    //if its children were dirtied \r\n    if(!paint_children)\r\n        return;\r\n\r\n    for(i = 0; i < window->children->count; i++) {\r\n\r\n        current_child = (Window*)List_get_at(window->children, i);\r\n\r\n        if(dirty_regions) {\r\n\r\n            //Check to see if the child is affected by any of the\r\n            //dirty region rectangles\r\n            for(j = 0; j < dirty_regions->count; j++) {\r\n            \r\n                temp_rect = (Rect*)List_get_at(dirty_regions, j);\r\n                \r\n                screen_x = Window_screen_x(current_child);\r\n                screen_y = Window_screen_y(current_child);\r\n\r\n                if(temp_rect->left <= (screen_x + current_child->width - 1) &&\r\n                   temp_rect->right >= screen_x &&\r\n                   temp_rect->top <= (screen_y + current_child->height - 1) &&\r\n                   temp_rect->bottom >= screen_y)\r\n                    break;\r\n            }\r\n\r\n            //Skip drawing this child if no intersection was found\r\n            if(j == dirty_regions->count)\r\n                continue;\r\n        }\r\n\r\n        //Otherwise, recursively request the child to redraw its dirty areas\r\n        Window_paint(current_child, dirty_regions, 1);\r\n    }\r\n}\r\n\r\n//This is the default paint method for a new window\r\nvoid Window_paint_handler(Window* window) {\r\n\r\n    //Fill in the window background\r\n    Context_fill_rect(window->context, 0, 0,\r\n                      window->width, window->height, WIN_BGCOLOR);\r\n}\r\n\r\n//Used to get a list of windows overlapping the passed window\r\nList* Window_get_windows_above(Window* parent, Window* child) {\r\n\r\n    int i;\r\n    Window* current_window;\r\n    List* return_list;\r\n\r\n    //Attempt to allocate the output list\r\n    if(!(return_list = List_new()))\r\n        return return_list;\r\n\r\n    //We just need to get a list of all items in the\r\n    //child list at higher indexes than the passed window\r\n    //We start by finding the passed child in the list\r\n    for(i = 0; i < parent->children->count; i++)\r\n        if(child == (Window*)List_get_at(parent->children, i))\r\n            break;\r\n\r\n    //Now we just need to add the remaining items in the list\r\n    //to the output (IF they overlap, of course)\r\n    //NOTE: As a bonus, this will also automatically fall through\r\n    //if the window wasn't found\r\n    for(i++; i < parent->children->count; i++) {\r\n\r\n        current_window = (Window*)List_get_at(parent->children, i);\r\n\r\n        if(current_window->flags & WIN_HIDDEN)\r\n            continue;\r\n\r\n        //Our good old rectangle intersection logic\r\n        if(current_window->x <= (child->x + child->width - 1) &&\r\n\t\t   (current_window->x + current_window->width - 1) >= child->x &&\r\n\t\t   current_window->y <= (child->y + child->height - 1) &&\r\n\t\t   (current_window->y + current_window->height - 1) >= child->y)\r\n            List_add(return_list, (Object*)current_window); //Insert the overlapping window\r\n    }\r\n\r\n    return return_list; \r\n}\r\n\r\n//Used to get a list of windows which the passed window overlaps\r\n//Same exact thing as get_windows_above, but goes backwards through\r\n//the list. Could probably be made a little less redundant if you really wanted\r\nList* Window_get_windows_below(Window* parent, Window* child) {\r\n\r\n    int i;\r\n    Window* current_window;\r\n    List* return_list;\r\n\r\n    //Attempt to allocate the output list\r\n    if(!(return_list = List_new()))\r\n        return return_list;\r\n\r\n    //We just need to get a list of all items in the\r\n    //child list at higher indexes than the passed window\r\n    //We start by finding the passed child in the list\r\n    for(i = parent->children->count - 1; i > -1; i--)\r\n        if(child == (Window*)List_get_at(parent->children, i))\r\n            break;\r\n\r\n    //Now we just need to add the remaining items in the list\r\n    //to the output (IF they overlap, of course)\r\n    //NOTE: As a bonus, this will also automatically fall through\r\n    //if the window wasn't found\r\n    for(i--; i > -1; i--) {\r\n\r\n        current_window = (Window*)List_get_at(parent->children, i);\r\n\r\n        if(current_window->flags & WIN_HIDDEN)\r\n            continue;\r\n\r\n        //Our good old rectangle intersection logic\r\n        if(current_window->x <= (child->x + child->width - 1) &&\r\n\t\t   (current_window->x + current_window->width - 1) >= child->x &&\r\n\t\t   current_window->y <= (child->y + child->height - 1) &&\r\n\t\t   (current_window->y + current_window->height - 1) >= child->y)\r\n            List_add(return_list, (Object*)current_window); //Insert the overlapping window\r\n    }\r\n\r\n    return return_list; \r\n}\r\n\r\n//Breaking \r\nvoid Window_raise(Window* window, uint8_t do_draw) {\r\n\r\n    int i;\r\n    Window* parent;\r\n    Window* last_active = (Window*)0;\r\n\r\n    if(window->flags & WIN_NORAISE)\r\n        return;\r\n\r\n    if(!window->parent)\r\n        return;\r\n\r\n    parent = window->parent;\r\n\r\n    if(parent->active_child == window)\r\n        return;\r\n\r\n    last_active = parent->active_child;\r\n\r\n    //Find the child in the list\r\n    for(i = 0; i < parent->children->count; i++)\r\n        if((Window*)List_get_at(parent->children, i) == window)\r\n            break;\r\n\r\n    List_remove_at(parent->children, i); //Pull window out of list\r\n    List_add(parent->children, (void*)window); //Insert at the top\r\n\r\n    //Make it active \r\n    parent->active_child = window;\r\n\r\n    //Do a redraw if it was requested\r\n    if(!do_draw)\r\n        return;\r\n\r\n    Window_paint(window, (List*)0, 1);\r\n\r\n    //Make sure the old active window gets an updated title color \r\n    if(last_active) \r\n        Window_update_title(last_active);\r\n}\r\n\r\nvoid Window_move(Window* window, int new_x, int new_y) {\r\n\r\n    if(window->move_function)\r\n        window->move_function(window, new_x, new_y);\r\n    else\r\n        Window_move_function(window, new_x, new_y);\r\n}\r\n\r\n//We're wrapping this guy so that we can handle any needed redraw\r\nvoid Window_move_function(Window* window, int new_x, int new_y) {\r\n\r\n    int i;\r\n    int old_x = window->x;\r\n    int old_y = window->y;\r\n    Rect new_window_rect;\r\n    List *replacement_list, *dirty_list, *dirty_windows;\r\n\r\n    //To make life a little bit easier, we'll make the not-unreasonable \r\n    //rule that if a window is moved, it must become the top-most window\r\n    Window_raise(window, 0); //Raise it, but don't repaint it yet\r\n\r\n    //We'll hijack our dirty rect collection from our existing clipping operations\r\n    //So, first we'll get the visible regions of the original window position\r\n    Window_apply_bound_clipping(window, window->context, 0, (List*)0);\r\n\r\n    //Temporarily update the window position\r\n    window->x = new_x;\r\n    window->y = new_y;\r\n\r\n    //Calculate the new bounds\r\n    new_window_rect.top = Window_screen_y(window);\r\n    new_window_rect.left = Window_screen_x(window);\r\n    new_window_rect.bottom = new_window_rect.top + window->height - 1;\r\n    new_window_rect.right = new_window_rect.left + window->width - 1;\r\n\r\n    //Reset the window position\r\n    window->x = old_x;\r\n    window->y = old_y;\r\n\r\n    //Now, we'll get the *actual* dirty area by subtracting the new location of\r\n    //the window \r\n    Context_subtract_clip_rect(window->context, &new_window_rect);\r\n\r\n    //Now that the context clipping tools made the list of dirty rects for us,\r\n    //we can go ahead and steal the list it made for our own purposes\r\n    //(yes, it would be cleaner to spin off our boolean rect functions so that\r\n    //they can be used both here and by the clipping region tools, but I ain't \r\n    //got time for that junk)\r\n    if(!(replacement_list = List_new())) {\r\n\r\n        Context_clear_clip_rects(window->context);\r\n        return;\r\n    }\r\n\r\n    dirty_list = window->context->clip_rects;\r\n    window->context->clip_rects = replacement_list;\r\n\r\n    //Now, let's get all of the siblings that we overlap before the move\r\n    dirty_windows = Window_get_windows_below(window->parent, window);\r\n\r\n    window->x = new_x;\r\n    window->y = new_y;\r\n\r\n    //And we'll repaint all of them using the dirty rects\r\n    //(removing them from the list as we go for convenience)\r\n    while(dirty_windows->count)\r\n        Window_paint((Window*)List_remove_at(dirty_windows, 0), dirty_list, 1);\r\n\r\n    //The one thing that might still be dirty is the parent we're inside of\r\n    Window_paint(window->parent, dirty_list, 0);\r\n\r\n    //We're done with the lists, so we can dump them\r\n    Object_delete((Object*)dirty_list);\r\n    Object_delete((Object*)dirty_windows);\r\n\r\n    //With the dirtied siblings redrawn, we can do the final update of \r\n    //the window location and paint it at that new position\r\n    Window_paint(window, (List*)0, 1);\r\n}\r\n\r\n//Interface between windowing system and mouse device\r\nvoid Window_process_mouse(Window* window, uint16_t mouse_x,\r\n                          uint16_t mouse_y, uint8_t mouse_buttons) {\r\n\r\n    int i, inner_x1, inner_y1, inner_x2, inner_y2;\r\n    Window* child;\r\n\r\n    if(window->drag_child) {\r\n\r\n        if(mouse_buttons) {\r\n\r\n            //Changed to use \r\n            Window_move(window->drag_child, mouse_x - window->drag_off_x,\r\n                        mouse_y - window->drag_off_y);\r\n            return;\r\n        } else {\r\n\r\n            window->drag_child = (Window*)0;\r\n        }\r\n    }\r\n\r\n    //If we had a button depressed, then we need to see if the mouse was\r\n    //over any of the child windows\r\n    //We go front-to-back in terms of the window stack for free occlusion\r\n    for(i = window->children->count - 1; i >= 0; i--) {\r\n\r\n        child = (Window*)List_get_at(window->children, i);\r\n\r\n        //If mouse isn't window bounds, we can't possibly be interacting with it \r\n        if(!(mouse_x >= child->x && mouse_x < (child->x + child->width) &&\r\n           mouse_y >= child->y && mouse_y < (child->y + child->height)) || \r\n           (child->flags & WIN_HIDDEN)) \r\n            continue;\r\n\r\n        //Do mouseover and mouseout events \r\n        if(child != window->over_child) {\r\n\r\n            if(window->over_child)\r\n                Window_mouseout(window->over_child);\r\n            else\r\n                Window_mouseout(window);\r\n\r\n            window->over_child = child;\r\n            Window_mouseover(window->over_child);\r\n        }            \r\n\r\n        //Now we'll check to see if we're dragging a titlebar\r\n        if(mouse_buttons && !window->last_button_state) {\r\n\r\n            //Let's adjust things so that a raise happens whenever we click inside a \r\n            //child, to be more consistent with most other GUIs\r\n            Window_raise(child, 1);\r\n\r\n            //See if the window has bodydrag enabled or \r\n            //See if the mouse position lies within the bounds of the current titlebar\r\n            //We check the decoration flag since we can't drag a window without a titlebar\r\n            if((child->flags & WIN_BODYDRAG) ||  (\r\n               !(child->flags & WIN_BODYDRAG) && !(child->flags & WIN_NODECORATION) &&\r\n               mouse_y >= child->y && mouse_y < (child->y + WIN_TITLEHEIGHT)\r\n               )) {\r\n\r\n                //We'll also set this window as the window being dragged\r\n                //until such a time as the mouse is released\r\n                window->drag_off_x = mouse_x - child->x;\r\n                window->drag_off_y = mouse_y - child->y;\r\n                window->drag_child = child;\r\n            }\r\n        }\r\n        \r\n        break;\r\n    }\r\n\r\n    //Do any not-over-a-child handling\r\n    if(i < 0) {\r\n\r\n        //If we were previously over a child, handle a mouseout event on it and clear the pointer\r\n        if(window->over_child) {\r\n\r\n            Window_mouseout(window->over_child);\r\n            window->over_child = (Window*)0;\r\n            \r\n            //We reentered the parent from a child, so fire a mouseover on the parent \r\n            Window_mouseover(window);\r\n        }\r\n\r\n        //If we didn't find a target in the search, then we ourselves are the target of any clicks\r\n        if(mouse_buttons && !window->last_button_state) \r\n            Window_mousedown(window, mouse_x, mouse_y);\r\n\r\n        if(!mouse_buttons && window->last_button_state)\r\n            Window_mouseup(window, mouse_x, mouse_y);\r\n\r\n        Window_mousemove(window, mouse_x, mouse_y);\r\n    } else {\r\n\r\n        //Found a target, so forward the mouse event to that window and quit looking\r\n        Window_process_mouse(child, mouse_x - child->x, mouse_y - child->y, mouse_buttons); \r\n\r\n        //Cancel any body drag if the mouse was found to be over a child in the dragged child \r\n        if((child->flags & WIN_BODYDRAG) && (window->drag_child == child) && !!child->over_child)\r\n            window->drag_child = (Window*)0;\r\n    }\r\n\r\n    //Update the stored mouse button state to match the current state \r\n    window->last_button_state = mouse_buttons;\r\n    if(window->click_cycle == 1)\r\n        window->click_cycle = 2;\r\n}\r\n\r\nvoid Window_update_context(Window* window, Context* context) {\r\n\r\n    int i;\r\n    Context* old_context = window->context;\r\n\r\n    window->context = context ? Context_new_from(context) : context;\r\n\r\n    for(i = 0; i < window->children->count; i++)\r\n        Window_update_context((Window*)List_get_at(window->children, i), context);\r\n\r\n    if(old_context)\r\n        Object_delete((Object*)old_context);\r\n}\r\n\r\n//Quick wrapper for shoving a new entry into the child list\r\nvoid Window_insert_child(Window* window, Window* child) {\r\n\r\n    child->parent = window;\r\n    List_add(window->children, (Object*)child);   \r\n    Window_update_context(child, window->context);\r\n    Window_raise(child, 1);\r\n}\r\n\r\n//A method to automatically create a new window in the provided parent window\r\nWindow* Window_create_window(Window* window, int16_t x, int16_t y,  \r\n                             uint16_t width, int16_t height, uint16_t flags) {\r\n\r\n    //Attempt to create the window instance\r\n    Window* new_window;\r\n    if(!(new_window = Window_new(x, y, width, height, flags, window->context)))\r\n        return new_window;\r\n\r\n    //Attempt to add the window to the end of the parent's children list\r\n    //If we fail, make sure to clean up all of our allocations so far \r\n    if(!List_add(window->children, (void*)new_window)) {\r\n\r\n        Object_delete((Object*)new_window);\r\n        return (Window*)0;\r\n    }\r\n\r\n    //Set the new child's parent \r\n    new_window->parent = window;\r\n\r\n    Window_raise(new_window, 1);\r\n\r\n    return new_window;\r\n}\r\n\r\n//Assign a string to the title of the window\r\nvoid Window_set_title(Window* window, char* new_title) {\r\n\r\n    int len, i;\r\n\r\n    //Make sure to free any preexisting title \r\n    if(window->title) {\r\n\r\n        for(len = 0; window->title[len]; len++);\r\n        free(window->title);\r\n    }\r\n\r\n    //We don't have strlen, so we're doing this manually\r\n    for(len = 0; new_title[len]; len++);\r\n\r\n    //Try to allocate new memory to clone the string\r\n    //(+1 because of the trailing zero in a c-string)\r\n    if(!(window->title = (char*)malloc((len + 1) * sizeof(char))))\r\n        return;\r\n\r\n    //Clone the passed string into the window's title\r\n    //Including terminating zero\r\n    for(i = 0; i <= len; i++)\r\n        window->title[i] = new_title[i];\r\n\r\n    //Make sure the change is reflected on-screen\r\n    if(window->flags & WIN_NODECORATION)\r\n        Window_invalidate(window, 0, 0, window->height - 1, window->width - 1);\r\n    else\r\n        Window_update_title(window);\r\n}\r\n\r\n//Add the characters from the passed string to the end of the window title\r\nvoid Window_append_title(Window* window, char* additional_chars) {\r\n\r\n    char* new_string;\r\n    int original_length, additional_length, i;\r\n\r\n    //Set the title if there isn't already one\r\n    if(!window->title) {\r\n\r\n        Window_set_title(window, additional_chars);\r\n        return;\r\n    }\r\n\r\n    //Get the length of the original string\r\n    for(original_length = 0; window->title[original_length]; original_length++);\r\n\r\n    //Get the length of the new string\r\n    for(additional_length = 0; additional_chars[additional_length]; additional_length++);\r\n\r\n    //Try to malloc a new string of the needed size\r\n    if(!(new_string = (char*)malloc(sizeof(char) * (original_length + additional_length + 1)))) {\r\n        return;\r\n    }\r\n\r\n    //Copy the base string into the new string\r\n    for(i = 0; window->title[i]; i++)\r\n        new_string[i] = window->title[i];\r\n\r\n    //Copy the appended chars into the new string\r\n    for(i = 0; additional_chars[i]; i++)\r\n        new_string[original_length + i] = additional_chars[i];\r\n\r\n    //Add the final zero char\r\n    new_string[original_length + i] = 0;\r\n\r\n    //And swap the string pointers\r\n    free(window->title);\r\n    window->title = new_string;\r\n\r\n    //Make sure the change is reflected on-screen\r\n    if(window->flags & WIN_NODECORATION)\r\n        Window_invalidate(window, 0, 0, window->height - 1, window->width - 1);\r\n    else\r\n        Window_update_title(window); \r\n}\r\n\r\nvoid Window_hide(Window* window) {\r\n\r\n    List* dirty_list;\r\n    Rect* dirty_rect;\r\n\r\n    if(!window->parent || (window->flags & WIN_HIDDEN))\r\n        return;\r\n\r\n    window->flags |= WIN_HIDDEN;\r\n    \r\n    //Build a dirty rect list for the mouse area\r\n    if(!(dirty_list = List_new()))\r\n        return;\r\n\r\n    if(!(dirty_rect = Rect_new(Window_screen_y(window), Window_screen_x(window), \r\n                               Window_screen_y(window) + window->height - 1,\r\n                               Window_screen_x(window) + window->width - 1))) {\r\n\r\n        Object_delete((Object*)dirty_list);\r\n        return;\r\n    }\r\n\r\n    List_add(dirty_list, (Object*)dirty_rect);\r\n\r\n    //Do a dirty update for the desktop, which will, in turn, do a \r\n    //dirty update for all affected child windows\r\n    Window_paint(window->parent, dirty_list, 1); \r\n\r\n    Object_delete((Object*)dirty_list);\r\n}\r\n\r\nvoid Window_show(Window* window) {\r\n\r\n    if(!(window->flags & WIN_HIDDEN))\r\n        return;\r\n\r\n    window->flags &= ~WIN_HIDDEN;\r\n\r\n    Window_paint(window, (List*)0, 1);\r\n}\r\n\r\nvoid Window_delete_function(Object* window_object) {\r\n\r\n    int i;\r\n    Window *window = (Window*)window_object;\r\n\r\n    if(!window_object)\r\n        return;\r\n\r\n    Window_hide(window);\r\n\r\n    Object_delete((Object*)window->children);\r\n\r\n    if(window->parent) {\r\n\r\n        for(i = 0;\r\n            i < window->parent->children->count && \r\n            (Window*)List_get_at(window->parent->children, i) != window; \r\n            i++);\r\n\r\n        if(i < window->parent->children->count)\r\n            List_remove_at(window->parent->children, i);\r\n\r\n        if(window->parent->active_child == window) {\r\n\r\n            if(window->parent->children->count) {\r\n\r\n                window->parent->active_child =\r\n                    (Window*)List_get_at(window->parent->children,\r\n                                         window->parent->children->count - 1);\r\n\r\n                Window_update_title(window->parent->active_child);\r\n            } else {\r\n\r\n                window->parent->active_child = (Window*)0;\r\n            }\r\n        }\r\n\r\n        if(window->parent->over_child == window)\r\n            window->parent->over_child = (Window*)0;\r\n        \r\n        if(window->parent->drag_child == window)\r\n            window->parent->drag_child = (Window*)0;\r\n    }\r\n\r\n    Object_delete((Object*)window->context);\r\n    free(window);\r\n}\r\n\r\nvoid Window_resize(Window* window, int w, int h) {\r\n\r\n    window->width = w;\r\n    window->height = h;\r\n\r\n    Window_paint(window, (List*)0, 1);\r\n}","#include \"module.h\"\r\n#include <stdlib.h>\r\n\r\nModule* Module_new(ModuleConstructor constructor, char* name) {\r\n\r\n    Module* module;\r\n    if(!(module = (Module*)malloc(sizeof(Module))))\r\n        return module;\r\n\r\n    Object_init((Object*)module, Module_delete_function);    \r\n    module->constructor = constructor;\r\n    \r\n    if(!(module->name = String_new(name))) {\r\n\r\n        Object_delete((Object*)module);\r\n        return (Module*)0;\r\n    }\r\n\r\n    return module;\r\n}\r\n\r\nvoid Module_delete_function(Object* module_object) {\r\n\r\n    if(!module_object)\r\n        return;\r\n\r\n    Module* module = (Module*)module_object;\r\n\r\n    Object_delete((Object*)module->name);\r\n    Object_default_delete_function(module_object);\r\n} ","#include \"patchcore.h\"\r\n#include \"../units/masterout.h\"\r\n#include \"../units/noise.h\"\r\n#include \"../units/pitchknob.h\"\r\n#include \"../units/sequence.h\"\r\n#include \"../units/sine.h\"\r\n#include \"../units/square.h\"\r\n#include <stdlib.h>\r\n\r\nPatchCore* PatchCore_new() {\r\n\r\n    PatchCore* patch;\r\n    if(!(patch = (PatchCore*)malloc(sizeof(PatchCore))))\r\n        return patch;\r\n\r\n    Object_init((Object*)patch, PatchCore_delete_function);\r\n    patch->modules = AssociativeArray_new();\r\n    patch->sources = List_new();\r\n    patch->desktop = (PatchDesktop*)0;\r\n    patch->inputs = List_new();\r\n\r\n    if(!(patch->modules && patch->sources && patch->inputs)) {\r\n\r\n        Object_delete((Object*)patch);\r\n        return (PatchCore*)0;\r\n    }\r\n\r\n    return patch;\r\n}\r\n\r\nint PatchCore_install_module(PatchCore* patch, Module* module) {\r\n\r\n    return AssociativeArray_add(patch->modules, module->name, (Object*)module);\r\n}\r\n\r\nint PatchCore_next_spawn_x(PatchCore* patch) {\r\n\r\n    return 0;\r\n}\r\n\r\nint PatchCore_next_spawn_y(PatchCore* patch) {\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Patch_mouse_callback(Object* desktop_object, uint16_t mouse_x,\r\n                           uint16_t mouse_y, uint8_t mouse_buttons) {\r\n\r\n    Desktop_process_mouse((Desktop*)desktop_object, mouse_x, mouse_y, mouse_buttons);\r\n}\r\n\r\nvoid Patch_resize_callback(Object* desktop_object, int w, int h) {\r\n\r\n    //Make sure that any changes to the root context get carried to all windows\r\n    Window_update_context((Window*)desktop_object, ((PatchDesktop*)desktop_object)->base_context);\r\n    Window_resize((Window*)desktop_object, w, h);\r\n}\r\n\r\nvoid PatchCore_start(PatchCore* patch) {\r\n\r\n    //TODO: This will be replaced by the loading of default modules from a list\r\n    PatchCore_install_module(patch, MasterOut_new());\r\n    PatchCore_install_module(patch, Noise_new());\r\n    PatchCore_install_module(patch, Sine_new());\r\n    PatchCore_install_module(patch, PitchKnob_new());\r\n    PatchCore_install_module(patch, Sequence_new());\r\n    PatchCore_install_module(patch, Square_new());\r\n\r\n    patch->desktop = PatchDesktop_new(patch);\r\n    PlatformWrapper_install_resize_callback((Object*)patch->desktop, Patch_resize_callback);\r\n    PlatformWrapper_install_mouse_callback((Object*)patch->desktop, Patch_mouse_callback);\r\n\r\n    Window_paint((Window*)patch->desktop, (List*)0, 1);\r\n\r\n    PlatformWrapper_install_audio_handler(AudioHandler_new(PatchCore_pull_sample, (Object*)patch));\r\n}\r\n\r\n\r\nint PatchCore_add_source(PatchCore* patch, IO* source) {\r\n\r\n    if(!source->is_output)\r\n        return 0;\r\n\r\n    return List_add(patch->sources, (Object*)source);\r\n}\r\n\r\nvoid PatchCore_remove_source(PatchCore* patch, IO* source) {\r\n\r\n    int i;\r\n\r\n    for(i = 0; i < patch->sources->count; i++)\r\n        if(List_get_at(patch->sources, i) == (Object*)source)\r\n            break;\r\n\r\n    if(i == patch->sources->count)\r\n        return;\r\n\r\n    List_remove_at(patch->sources, i);\r\n}\r\n\r\nList* PatchCore_get_module_list(PatchCore* patch) {\r\n\r\n    return patch->modules->keys;\r\n}\r\n\r\nvoid PatchCore_connect_action(PatchCore* patch, IO* io) {\r\n\r\n    PatchDesktop_connect_action(patch->desktop, io);\r\n}\r\n\r\nvoid PatchCore_destroy_menu(PatchCore* patch) {\r\n    \r\n    Object_delete((Object*)patch->desktop->menu);\r\n    patch->desktop->menu = (SessionMenu*)0;\r\n}\r\n\r\nvoid PatchCore_instantiate_module(PatchCore* patch, String* module_name) {\r\n\r\n    Module* module;\r\n    Window* window;\r\n\r\n    module = (Module*)AssociativeArray_get(patch->modules, module_name);\r\n    if(!module)\r\n        return;\r\n\r\n    window = (Window*)module->constructor(patch);\r\n    if(!window)\r\n        return;\r\n\r\n    Window_insert_child((Window*)patch->desktop, window);\r\n    Window_move(window, PatchCore_next_spawn_x(patch), PatchCore_next_spawn_y(patch));\r\n}\r\n\r\nvoid PatchCore_pull_sample(Object* patch_object, double* sample_l, double* sample_r) {\r\n\r\n    int i;\r\n    IO* source;\r\n    double temp_l, temp_r;\r\n    PatchCore* patch = (PatchCore*)patch_object;\r\n\r\n    *sample_r = 0;\r\n    *sample_l = 0;\r\n\r\n    for(i = 0; i < patch->sources->count; i++) {\r\n\r\n        source = (IO*)List_get_at(patch->sources, i);\r\n        \r\n        IO_pull_sample(source, &temp_l, &temp_r);\r\n        *sample_r += temp_r;\r\n        *sample_l += temp_l;\r\n    }\r\n}\r\n\r\nvoid PatchCore_delete_function(Object* patch_object) {\r\n    \r\n    Module* module;\r\n    PatchCore* patch = (PatchCore*)patch_object;\r\n\r\n    Object_delete((Object*)patch->modules);\r\n    Object_delete((Object*)patch->sources);\r\n    Object_delete((Object*)patch->desktop);\r\n    Object_delete((Object*)patch->inputs);\r\n    Object_default_delete_function(patch_object);\r\n}\r\n","#include \"io.h\"\r\n\r\n//NOTE: IOs need to automatically disconnect from anything they might be\r\n//      connected to upon deletion so that we don't get invalid pulls\r\n\r\nint Output_initial_sample_pull_handler(IO* io, double *l_sample, double *r_sample) {\r\n\r\n    *l_sample = *r_sample = 0.0;\r\n\r\n    return 1;\r\n}\r\n\r\nint Input_sample_pull_handler(IO* io, double *l_sample, double *r_sample) {\r\n\r\n    if(io->connected_io)\r\n        return IO_pull_sample(io->connected_io, l_sample, r_sample);\r\n    else\r\n        *l_sample = *r_sample = 0.0;\r\n    \r\n    return 1;\r\n}\r\n\r\nIO* IO_new(PatchCore* patch_core, Object* param_object, int x, int y, int is_output) {\r\n\r\n    IO* io = (IO*)malloc(sizeof(IO));\r\n    \r\n    if(!io)\r\n        return io;\r\n\r\n    if(!IO_init(io, patch_core, param_object, x, y, is_output)) {\r\n\r\n        Object_delete((Object*)io);\r\n        return (IO*)0;\r\n    }\r\n\r\n    if(!is_output)\r\n        List_add(patch_core->inputs, (Object*)io);\r\n\r\n    return io;\r\n}\r\n\r\nint IO_init(IO* io, PatchCore* patch_core, Object* param_object, int x, int y, int is_output) {\r\n\r\n    if(!Window_init((Window*)io, x - 3, y - 3, 6, 6,\r\n                    WIN_NODECORATION | WIN_NORAISE, (Context*)0)) \r\n        return 0;\r\n    \r\n    //Initial init\r\n    io->window.paint_function = IO_paint_handler;\r\n    io->window.mouseclick_function = IO_mouseclick_handler;\r\n    io->patch_core = patch_core; \r\n    io->param_object= param_object;\r\n    io->connected_io = (IO*)0;\r\n    io->is_output = is_output;\r\n\r\n    if(is_output)\r\n        io->pull_sample_function = Output_initial_sample_pull_handler;\r\n    else\r\n        io->pull_sample_function = Input_sample_pull_handler;\r\n\r\n    return 1;\r\n}\r\n\r\nvoid IO_paint_handler(Window* io_window) {\r\n\r\n    IO* io = (IO*)io_window;\r\n\r\n    Context_fill_rect(io_window->context, 2, 2, 2, 2,\r\n                      io->connected_io ? RGB(0, 200, 0) : RGB(100, 100, 100));\r\n    Context_draw_rect(io_window->context, 0, 0, 6, 6, RGB(0, 0, 0));\r\n    Context_draw_rect(io_window->context, 1, 1, 4, 4, RGB(0, 0, 0));\r\n}\r\n\r\nvoid IO_mouseclick_handler(Window* io_window, int x, int y) {\r\n\r\n    IO* io = (IO*)io_window;\r\n\r\n    if(io->connected_io) {\r\n\r\n        io->connected_io->connected_io = (IO*)0;\r\n        io->connected_io = (IO*)0;\r\n    }\r\n\r\n    PatchCore_connect_action(io->patch_core, io);\r\n}\r\n\r\nvoid IO_connect(IO* io, IO* connected_io) {\r\n\r\n    io->connected_io = connected_io;\r\n}\r\n\r\nint IO_pull_sample(IO* io, double *l_sample, double *r_sample) {\r\n\r\n    return io->pull_sample_function(io, l_sample, r_sample);\r\n}\r\n","#include \"audiohandler.h\"\r\n#include <stdlib.h>\r\n\r\nAudioHandler* AudioHandler_new(AudioHandlerFunction function, Object* parent_object) {\r\n\r\n    AudioHandler* audio_handler;\r\n    if(!(audio_handler = (AudioHandler*)malloc(sizeof(AudioHandler))))\r\n        return audio_handler;\r\n\r\n    Object_init((Object*)audio_handler, 0);\r\n    audio_handler->function = function;\r\n    audio_handler->parent_object = parent_object;\r\n\r\n    return audio_handler;\r\n}\r\n","#include \"unit.h\"\r\n#include \"../wslib/list.h\"\r\n\r\nUnit* Unit_new(PatchCore* patch_core) {\r\n\r\n    Unit* unit;\r\n    if(!(unit = (Unit*)malloc(sizeof(Unit))))\r\n        return unit;\r\n\r\n    if(!Unit_init(unit, patch_core)) {\r\n\r\n        Object_delete((Object*)unit);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    return unit;\r\n}\r\n\r\nvoid Unit_move_function(Window* unit_window, int x, int y) {\r\n\r\n    Unit* unit = (Unit*)unit_window;\r\n\r\n    unit->old_move(unit_window, x, y);\r\n\r\n    //Cheap method to force elbow redraws\r\n    if(unit_window->parent) {\r\n\r\n        Window_invalidate(unit_window->parent, 0, 0,\r\n                          unit_window->parent->height - 1,\r\n                          unit_window->parent->width - 1);\r\n    }\r\n}\r\n\r\nint Unit_init(Unit* unit, PatchCore* patch_core) {\r\n\r\n    if(!Frame_init((Frame*)unit, 0, 0, 100, 100))\r\n        return 0;\r\n\r\n    unit->patch_core = patch_core;\r\n    unit->old_move = unit->frame.window.move_function;\r\n    unit->frame.window.move_function = Unit_move_function;\r\n\r\n    return 1;\r\n}\r\n\r\nIO* Unit_create_io(Unit* unit, int x, int y, uint8_t is_output) {\r\n\r\n    IO* io = IO_new(unit->patch_core, (Object*)unit, x, y, is_output);\r\n\r\n    if(!io)\r\n        return io;\r\n\r\n    Window_insert_child((Window*)unit, (Window*)io);\r\n\r\n    return io;\r\n}\r\n\r\nIO* Unit_create_output(Unit* unit, int x, int y) {\r\n\r\n    IO* io = Unit_create_io(unit, x, y, 1);\r\n\r\n    return io;\r\n}\r\n\r\nIO* Unit_create_input(Unit* unit, int x, int y) {\r\n\r\n    return Unit_create_io(unit, x, y, 0);\r\n}\r\n\r\nvoid Unit_delete(Object* unit_object) {\r\n\r\n    Window_delete_function(unit_object);\r\n}\r\n","#include \"frame.h\"\r\n\r\nFrame* Frame_new(int x, int y, int width, int height) {\r\n\r\n    Frame* frame;\r\n    if(!(frame = (Frame*)malloc(sizeof(Frame))))\r\n        return frame;\r\n\r\n    if(!Frame_init(frame, x, y, width, height)) {\r\n\r\n        free(frame);\r\n        return (Frame*)0;\r\n    }\r\n\r\n    return frame;\r\n}\r\n\r\nint Frame_init(Frame* frame, int x, int y, int width, int height) {\r\n\r\n    if(!Window_init((Window*)frame, x, y, width, height,\r\n                    WIN_BODYDRAG | WIN_NODECORATION, (Context*)0)) \r\n        return 0;\r\n\r\n    frame->window.paint_function = Frame_paint_handler;\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Frame_paint_handler(Window* frame_window) {\r\n\r\n    Context_fill_rect(frame_window->context, 2, 2, frame_window->width - 4,\r\n                      frame_window->height - 4, RGB(155, 165, 185));\r\n    Context_draw_rect(frame_window->context, 0, 0, frame_window->width,\r\n                      frame_window->height, RGB(0, 0, 0));\r\n    Context_draw_rect(frame_window->context, 1, 1, frame_window->width - 2,\r\n                      frame_window->height - 2, RGB(0, 0, 0));\r\n}\r\n\r\n","#include \"menuentry.h\"\r\n\r\nMenuEntry* MenuEntry_new(String* text, WindowMouseclickHandler click_action) {\r\n\r\n    MenuEntry* menu_entry;\r\n\r\n    if(!(menu_entry = (MenuEntry*)malloc(sizeof(MenuEntry))))\r\n        return menu_entry;\r\n\r\n    if(!(Window_init((Window*)menu_entry, 0, 0, 100, 14, WIN_NORAISE | WIN_NODECORATION, (Context*)0))) {\r\n\r\n        Object_delete((Object*)menu_entry);\r\n        return (MenuEntry*)0;\r\n    }\r\n\r\n    Object_init((Object*)menu_entry, MenuEntry_delete_function);\r\n\r\n    if(!(menu_entry->text = String_new(text->buf))) {\r\n\r\n        Object_delete((Object*)menu_entry);\r\n        return (MenuEntry*)0;\r\n    }\r\n\r\n    menu_entry->mouse_over = 0;\r\n    menu_entry->window.paint_function = MenuEntry_paint_handler;\r\n    menu_entry->window.mouseclick_function = click_action;\r\n    menu_entry->window.mouseover_function = MenuEntry_mouseover_handler;\r\n    menu_entry->window.mouseout_function = MenuEntry_mouseout_handler;\r\n\r\n    return menu_entry;\r\n}\r\n\r\nvoid MenuEntry_toggle_over(Window* menu_entry_window, int over) {\r\n\r\n    MenuEntry* menu_entry = (MenuEntry*)menu_entry_window;\r\n\r\n    menu_entry->mouse_over = over;\r\n    Window_invalidate(menu_entry_window, 0, 0, menu_entry_window->height - 1,\r\n                      menu_entry_window->width - 1);\r\n}\r\n\r\nvoid MenuEntry_mouseover_handler(Window* menu_entry_window) {\r\n\r\n    MenuEntry_toggle_over(menu_entry_window, 1);\r\n}\r\n\r\nvoid MenuEntry_mouseout_handler(Window* menu_entry_window) {\r\n\r\n    MenuEntry_toggle_over(menu_entry_window, 0);\r\n}\r\n\r\nvoid MenuEntry_paint_handler(Window* menu_entry_window) {\r\n\r\n    MenuEntry* menu_entry = (MenuEntry*)menu_entry_window;\r\n\r\n    //Current code assumes that the font is 12px high\r\n    Context_fill_rect(menu_entry_window->context, 0, 0, menu_entry_window->width,\r\n                      menu_entry_window->height,\r\n                      menu_entry->mouse_over ? RGB(0, 0, 0) : RGB(155, 165, 185));\r\n    Context_draw_text(menu_entry_window->context, menu_entry->text->buf,\r\n                      1, 1, menu_entry->mouse_over ? RGB(255, 255, 255) : RGB(0, 0, 0));\r\n}\r\n\r\nvoid MenuEntry_delete_function(Object* menu_entry_object) {\r\n\r\n    if(!menu_entry_object)\r\n        return;\r\n\r\n    MenuEntry* menu_entry = (MenuEntry*)menu_entry_object;\r\n\r\n    Object_delete((Object*)menu_entry->text);\r\n    Window_delete_function(menu_entry_object);\r\n}\r\n","\r\n#include \"sessionmenu.h\"\r\n\r\nSessionMenu* SessionMenu_new(PatchCore* patch_core, int x, int y) {\r\n\r\n    int i;\r\n    SessionMenu* session_menu = (SessionMenu*)malloc(sizeof(SessionMenu));\r\n\r\n    if(!session_menu)\r\n        return session_menu;\r\n\r\n    if(!Menu_init((Menu*)session_menu, x, y, 200)) {\r\n\r\n        Object_delete((Object*)session_menu);\r\n        return (SessionMenu*)0;\r\n    }\r\n\r\n    session_menu->patch_core = patch_core;\r\n    session_menu->module_names = PatchCore_get_module_list(patch_core);\r\n\r\n    //TODO: Need to add a sanity check in the case that the new menu entry\r\n    //couldn't be properly instantiated\r\n    for(i = 0; session_menu->module_names && (i < session_menu->module_names->count); i++)\r\n        Menu_add_entry((Menu*)session_menu,\r\n                       MenuEntry_new((String*)List_get_at(session_menu->module_names, i), SessionMenu_mouseclick_function));\r\n\r\n    return session_menu;\r\n}\r\n\r\nvoid SessionMenu_mouseclick_function(Window* session_menu_entry_window, int x, int y) {\r\n\r\n    if(!session_menu_entry_window->parent)\r\n        return;\r\n\r\n    MenuEntry* menu_entry = (MenuEntry*)session_menu_entry_window;\r\n    SessionMenu* session_menu = (SessionMenu*)session_menu_entry_window->parent;\r\n\r\n    PatchCore_instantiate_module(session_menu->patch_core, menu_entry->text);\r\n    PatchCore_destroy_menu(session_menu->patch_core);\r\n}\r\n","#include \"slider.h\"\r\n\r\nvoid Slider_knob_move(Window* knob_window, int x, int y) {\r\n\r\n    Frame* knob = (Frame*)knob_window;\r\n    Slider* slider = (Slider*)knob->window.parent;\r\n\r\n    if(!slider)\r\n        return;\r\n\r\n    if(y < 0)\r\n        y = 0;\r\n\r\n    if(y > (slider->window.height - 10))\r\n        y = slider->window.height - 10;\r\n\r\n    if(slider->knob_old_move)\r\n        slider->knob_old_move(knob_window, 0, y);\r\n}\r\n\r\nSlider* Slider_new(int x, int y, int width, int height, double min, double max) {\r\n\r\n    Slider* slider;\r\n\r\n    if(!(slider = (Slider*)malloc(sizeof(Slider))))\r\n        return slider;\r\n\r\n    if(!Window_init((Window*)slider, x, y, width, height, WIN_NODECORATION, (Context*)0)) {\r\n\r\n        free(slider);\r\n        return (Slider*)0;\r\n    }\r\n\r\n    if(!(slider->knob = Frame_new(0, 0, width, 10))) {\r\n\r\n        Object_delete((Object*)slider);\r\n        return (Slider*)0;\r\n    }\r\n\r\n    Window_insert_child((Window*)slider, (Window*)slider->knob);\r\n\r\n    slider->value = 0;\r\n    slider->min = min; \r\n    slider->max = max; \r\n    slider->knob_old_move = slider->knob->window.move_function; \r\n    slider->knob->window.move_function = Slider_knob_move;\r\n    slider->window.object.delete_function = Slider_delete_function;\r\n\r\n    return slider;\r\n}\r\n\r\ndouble Slider_get_value(Slider* slider) {\r\n\r\n    double y = (double)slider->knob->window.y;\r\n    double x = (double)slider->knob->window.x;\r\n    double height = (double)slider->window.height;\r\n\r\n    return (((y - height + 10) * (slider->max - slider->min)) / (-(height - 10))) - slider->min;\r\n}\r\n\r\nvoid Slider_set_value(Slider* slider, double new_value) {\r\n\r\n    double height = (double)slider->window.height;\r\n\r\n    if(new_value > slider->max)\r\n        new_value = slider->max;\r\n\r\n    if(new_value < slider->min)\r\n       new_value = slider->min;\r\n\r\n    double new_y = \r\n        (((-(height - 10)) / (slider->max - slider->min)) * (new_value - slider->min)) + (height - 10);\r\n\r\n    Window_move((Window*)slider->knob, 0, (int)new_y);\r\n}\r\n\r\nvoid Slider_delete_function(Object* slider_object) {\r\n\r\n    Slider* slider = (Slider*)slider_object;\r\n\r\n    Object_delete((Object*)slider->knob);\r\n    Window_delete_function(slider_object);\r\n}\r\n","#include \"math.h\"\r\n#include \"masterout.h\"\r\n\r\nModule* MasterOut_new() {\r\n\r\n    return Module_new(MasterOut_constructor, \"Master Out\");\r\n}\r\n\r\ndouble db2gain(double value) {\r\n\r\n    double max_db = 10;\r\n    double min_db = -80;\r\n    double db_value = ((max_db - min_db) * value) + min_db;\r\n    double gain_value = (pow(10,(db_value/20)) - pow(10,(min_db/20))) / (1 - pow(10, (min_db/20)));\r\n\r\n    return gain_value;\r\n}\r\n\r\nint MasterOut_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n\r\n    MasterOut* master_out = (MasterOut*)io->param_object;\r\n\r\n    int retval = IO_pull_sample(master_out->input, sample_l, sample_r);\r\n    \r\n    *sample_l *= db2gain(Slider_get_value(master_out->slider));\r\n    *sample_r *= db2gain(Slider_get_value(master_out->slider));\r\n\r\n    return retval;\r\n}\r\n\r\nvoid MasterOut_delete_function(Object* master_out_object) {\r\n\r\n    MasterOut* master_out = (MasterOut*)master_out_object;\r\n\r\n    //Need to do this since, because the output IO never gets installed \r\n    //as a child of the window, it won't be deleted by the window deleter\r\n    Object_delete((Object*)(Object*)master_out->output);\r\n    Unit_delete(master_out_object);\r\n}\r\n\r\nvoid MasterOut_paint_handler(Window* master_out_window) {\r\n\r\n    Frame_paint_handler(master_out_window);\r\n    Context_draw_text(master_out_window->context, \"Master Out\",\r\n                       (master_out_window->width / 2) - 40,\r\n                       (master_out_window->height / 2) - 6,\r\n                       WIN_BORDERCOLOR);     \r\n}\r\n\r\nUnit* MasterOut_constructor(PatchCore* patch_core) {\r\n\r\n    MasterOut* master_out = (MasterOut*)malloc(sizeof(MasterOut));\r\n\r\n    if(!master_out)\r\n        return (Unit*)master_out;\r\n\r\n    if(!Unit_init((Unit*)master_out, patch_core)) {\r\n\r\n        Object_delete((Object*)master_out);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    Object_init((Object*)master_out, MasterOut_delete_function);\r\n    master_out->slider = Slider_new(10, 10, 30, 130, 0, 1);\r\n    master_out->input = Unit_create_input((Unit*)master_out, 5, 75);\r\n    master_out->output = IO_new(patch_core, (Object*)master_out, 0, 0, 1);\r\n\r\n    if(!(master_out->slider && master_out->input && master_out->output)) {\r\n\r\n        Object_delete((Object*)master_out);\r\n        return (Unit*)0;\r\n    }    \r\n\r\n    Window_insert_child((Window*)master_out, (Window*)master_out->slider);\r\n    Window_resize((Window*)master_out, 200, 150);\r\n\r\n    master_out->output->pull_sample_function = MasterOut_pull_sample_handler;\r\n    master_out->unit.frame.window.paint_function = MasterOut_paint_handler;\r\n    PatchCore_add_source(patch_core, master_out->output);\r\n\r\n    return (Unit*)master_out;\r\n}\r\n","#include <stdio.h>\r\n#include <time.h>\r\n#include <stdlib.h>\r\n#include \"noise.h\"\r\n\r\nModule* Noise_new() {\r\n\r\n    return Module_new(Noise_constructor, \"Noise\");\r\n}\r\n\r\ndouble double_rand() {\r\n\r\n    time_t t;\r\n    \r\n    srand((unsigned) time(&t));\r\n    return (((double)rand() / (double)RAND_MAX) - 0.5) * 2;\r\n}\r\n\r\nint Noise_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n\r\n    //Not really used here, but whatever\r\n    Noise* noise = (Noise*)io->param_object;\r\n\r\n    //Stereo noise\r\n    *sample_l = double_rand();\r\n    *sample_r = double_rand();\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Noise_paint_handler(Window* noise_window) {\r\n\r\n    Frame_paint_handler(noise_window);\r\n    Context_draw_text(noise_window->context, \"Noise\",\r\n                       (noise_window->width / 2) - 20,\r\n                       (noise_window->height / 2) - 6,\r\n                       WIN_BORDERCOLOR);     \r\n}\r\n\r\nUnit* Noise_constructor(PatchCore* patch_core) {\r\n\r\n    Noise* noise = (Noise*)malloc(sizeof(Noise));\r\n\r\n    if(!noise)\r\n        return (Unit*)noise;\r\n\r\n    if(!Unit_init((Unit*)noise, patch_core)) {\r\n\r\n        Object_delete((Object*)noise);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    noise->output = Unit_create_output((Unit*)noise, 195, 75);\r\n    Window_resize((Window*)noise, 200, 150);\r\n\r\n    if(!(noise->output)) {\r\n\r\n        Object_delete((Object*)noise);\r\n        return (Unit*)0;\r\n    }    \r\n   \r\n    noise->output->pull_sample_function = Noise_pull_sample_handler;\r\n    noise->unit.frame.window.paint_function = Noise_paint_handler;\r\n\r\n    return (Unit*)noise;\r\n}","#include <math.h>\r\n#include \"pitchknob.h\"\r\n\r\nModule* PitchKnob_new() {\r\n\r\n    return Module_new(PitchKnob_constructor, \"Pitch Knob\");\r\n}\r\n\r\nint PitchKnob_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n\r\n    PitchKnob* pitch_knob = (PitchKnob*)io->param_object;\r\n\r\n    *sample_l = *sample_r =\r\n        2*(pow(2, ((1 - Slider_get_value(pitch_knob->slider)) * 6))); \r\n\r\n    return 1;\r\n}\r\n\r\nUnit* PitchKnob_constructor(PatchCore* patch_core) {\r\n\r\n    PitchKnob* pitch_knob = (PitchKnob*)malloc(sizeof(PitchKnob));\r\n\r\n    if(!pitch_knob)\r\n        return (Unit*)pitch_knob;\r\n\r\n    if(!Unit_init((Unit*)pitch_knob, patch_core)) {\r\n\r\n        Object_delete((Object*)pitch_knob);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    pitch_knob->slider = Slider_new(10, 10, 30, 130, 0, 1);\r\n\r\n    if(pitch_knob->slider)\r\n        Window_insert_child((Window*)pitch_knob, (Window*)pitch_knob->slider);\r\n\r\n    pitch_knob->output = Unit_create_output((Unit*)pitch_knob, 45, 75);\r\n\r\n    if(!(pitch_knob->slider && pitch_knob->output)) {\r\n\r\n        Object_delete((Object*)pitch_knob);\r\n        return (Unit*)0;\r\n    }    \r\n\r\n    Window_resize((Window*)pitch_knob, 50, 150);\r\n    pitch_knob->output->pull_sample_function = PitchKnob_pull_sample_handler;\r\n\r\n    return (Unit*)pitch_knob;\r\n}","#include \"sequence.h\"\r\n\r\nModule* Sequence_new() {\r\n\r\n    return Module_new(Sequence_constructor, \"Sequence\");\r\n}\r\n\r\nint Sequence_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n\r\n    Sequence* sequence = (Sequence*)io->param_object;\r\n\r\n    int i;\r\n    double current_clock_sample_l,\r\n           current_clock_sample_r,\r\n           step_sample_l[8],\r\n           step_sample_r[8];\r\n\r\n    if(!IO_pull_sample(sequence->clock_in, &current_clock_sample_l, &current_clock_sample_r))\r\n        return 0;\r\n\r\n    if(current_clock_sample_l > 0 && sequence->last_clock_sample <= 0)\r\n        sequence->current_step++;\r\n\r\n    sequence->last_clock_sample = current_clock_sample_l;\r\n\r\n    if(sequence->current_step == 8)\r\n        sequence->current_step = 0;\r\n\r\n    for(i = 0; i < 8; i++) {\r\n\r\n        if(!IO_pull_sample((IO*)List_get_at(sequence->step_list, i), \r\n                           &step_sample_l[i], &step_sample_r[i]))\r\n            return 0;\r\n    }\r\n\r\n    *sample_l = step_sample_l[sequence->current_step];\r\n    *sample_r = step_sample_r[sequence->current_step];\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Sequence_delete_function(Object* sequence_object) {\r\n\r\n    Sequence* sequence = (Sequence*)sequence_object;\r\n\r\n    //Clear the list so that the elements don't get freed on list\r\n    //deletion and then double-freed on window deletion\r\n    while(sequence->step_list && sequence->step_list->count)\r\n        List_remove_at(sequence->step_list, 0);\r\n\r\n    //Delete the emptied step list\r\n    Object_delete((Object*)sequence->step_list);\r\n    Unit_delete(sequence_object);\r\n}\r\n\r\nvoid Sequence_paint_handler(Window* sequence_window) {\r\n\r\n    Frame_paint_handler(sequence_window);\r\n    Context_draw_text(sequence_window->context, \"Sequence\",\r\n                       (sequence_window->width / 2) - 32,\r\n                       (sequence_window->height / 2) - 6,\r\n                       WIN_BORDERCOLOR);     \r\n}\r\n\r\nUnit* Sequence_constructor(PatchCore* patch_core) {\r\n\r\n    int i;\r\n    IO* temp_input;\r\n    Sequence* sequence = (Sequence*)malloc(sizeof(Sequence));\r\n\r\n    if(!sequence)\r\n        return (Unit*)sequence;\r\n\r\n    if(!Unit_init((Unit*)sequence, patch_core)) {\r\n\r\n        Object_delete((Object*)sequence);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    Object_init((Object*)sequence, Sequence_delete_function);\r\n\r\n    sequence->step_list = List_new();\r\n\r\n    if(!sequence->step_list) {\r\n\r\n        Object_delete((Object*)sequence);\r\n        return (Unit*)0;\r\n    }    \r\n\r\n    \r\n    for(i = 0; i < 8; i++) {\r\n\r\n        temp_input = Unit_create_input((Unit*)sequence, 20*(i+1), 5);\r\n\r\n        if(!temp_input) {\r\n\r\n            Object_delete((Object*)sequence);\r\n            return (Unit*)0;\r\n        }    \r\n\r\n        List_add(sequence->step_list, (Object*)temp_input);\r\n    }\r\n\r\n    sequence->output = Unit_create_output((Unit*)sequence, 195, 75);\r\n    sequence->clock_in = Unit_create_input((Unit*)sequence, 5, 75);\r\n\r\n    if(!(sequence->clock_in && sequence->output)) {\r\n\r\n        Object_delete((Object*)sequence);\r\n        return (Unit*)0;\r\n    }    \r\n\r\n    Window_resize((Window*)sequence, 200, 150);\r\n    sequence->output->pull_sample_function = Sequence_pull_sample_handler;\r\n    sequence->current_step = 0;\r\n    sequence->last_clock_sample = 0;\r\n    sequence->unit.frame.window.paint_function = Sequence_paint_handler;\r\n\r\n    return (Unit*)sequence;\r\n}","#include <math.h>\r\n#include \"sine.h\"\r\n#include \"../platform/platformwrapper.h\"\r\n\r\nModule* Sine_new() {\r\n\r\n    return Module_new(Sine_constructor, \"Sine\");\r\n}\r\n\r\nint Sine_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n    \r\n    double in_sample_l, in_sample_r;\r\n    Sine* sine = (Sine*)io->param_object;\r\n\r\n    *sample_l = *sample_r = sin(sine->phase);\r\n    \r\n    if(!IO_pull_sample(sine->freq_in, &in_sample_l, &in_sample_r))\r\n        return 0;\r\n\r\n    sine->phase = (sine->phase + (((2*M_PI) * in_sample_l)/SAMPLE_RATE));\r\n\r\n    if(sine->phase > (2*M_PI))\r\n        sine->phase -= (2*M_PI);\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Sine_paint_handler(Window* sine_window) {\r\n\r\n    Frame_paint_handler(sine_window);\r\n    Context_draw_text(sine_window->context, \"Sine\",\r\n                       (sine_window->width / 2) - 16,\r\n                       (sine_window->height / 2) - 6,\r\n                       WIN_BORDERCOLOR);     \r\n}\r\n\r\nUnit* Sine_constructor(PatchCore* patch_core) {\r\n\r\n    Sine* sine = (Sine*)malloc(sizeof(Sine));\r\n\r\n    if(!sine)\r\n        return (Unit*)sine;\r\n\r\n    if(!Unit_init((Unit*)sine, patch_core)) {\r\n\r\n        Object_delete((Object*)sine);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    sine->output = Unit_create_output((Unit*)sine, 195, 75);\r\n    sine->freq_in = Unit_create_input((Unit*)sine, 5, 75);\r\n    Window_resize((Window*)sine, 200, 150);\r\n\r\n    if(!(sine->output && sine->freq_in)) {\r\n\r\n        Object_delete((Object*)sine);\r\n        return (Unit*)0;\r\n    }    \r\n   \r\n    sine->phase = 0;\r\n    sine->output->pull_sample_function = Sine_pull_sample_handler;\r\n    sine->unit.frame.window.paint_function = Sine_paint_handler;\r\n\r\n    return (Unit*)sine;\r\n}","#include <math.h>\r\n#include \"square.h\"\r\n#include \"../platform/platformwrapper.h\"\r\n\r\nModule* Square_new() {\r\n\r\n    return Module_new(Square_constructor, \"Square\");\r\n}\r\n\r\nint Square_pull_sample_handler(IO* io, double* sample_l, double* sample_r) {\r\n    \r\n    double in_sample_l, in_sample_r;\r\n    Square* square = (Square*)io->param_object;\r\n\r\n    *sample_l = *sample_r = square->phase > M_PI ? 1.0 : -1.0;\r\n    \r\n    if(!IO_pull_sample(square->freq_in, &in_sample_l, &in_sample_r))\r\n        return 0;\r\n\r\n    square->phase = (square->phase + (((2*M_PI) * in_sample_l)/SAMPLE_RATE));\r\n\r\n    if(square->phase > (2*M_PI))\r\n        square->phase -= (2*M_PI);\r\n\r\n    return 1;\r\n}\r\n\r\nvoid Square_paint_handler(Window* square_window) {\r\n\r\n    Frame_paint_handler(square_window);\r\n    Context_draw_text(square_window->context, \"Square\",\r\n                       (square_window->width / 2) - 24,\r\n                       (square_window->height / 2) - 6,\r\n                       WIN_BORDERCOLOR);     \r\n}\r\n\r\nUnit* Square_constructor(PatchCore* patch_core) {\r\n\r\n    Square* square = (Square*)malloc(sizeof(Square));\r\n\r\n    if(!square)\r\n        return (Unit*)square;\r\n\r\n    if(!Unit_init((Unit*)square, patch_core)) {\r\n\r\n        Object_delete((Object*)square);\r\n        return (Unit*)0;\r\n    }\r\n\r\n    square->output = Unit_create_output((Unit*)square, 195, 75);\r\n    square->freq_in = Unit_create_input((Unit*)square, 5, 75);\r\n    Window_resize((Window*)square, 200, 150);\r\n\r\n    if(!(square->output && square->freq_in)) {\r\n\r\n        Object_delete((Object*)square);\r\n        return (Unit*)0;\r\n    }    \r\n   \r\n    square->phase = 0;\r\n    square->output->pull_sample_function = Square_pull_sample_handler;\r\n    square->unit.frame.window.paint_function = Square_paint_handler;\r\n\r\n    return (Unit*)square;\r\n}","#include \"patchdesktop.h\"\r\n\r\nPatchDesktop* PatchDesktop_new(PatchCore* patch_core) {\r\n\r\n    PatchDesktop* patch_desktop = (PatchDesktop*)malloc(sizeof(PatchDesktop));\r\n    \r\n    if(!patch_desktop)\r\n        return patch_desktop;\r\n\r\n    if(!(patch_desktop->base_context = PlatformWrapper_get_context())) {\r\n\r\n        Object_delete((Object*)patch_desktop);\r\n        return (PatchDesktop*)0;\r\n    }\r\n\r\n    if(!Desktop_init((Desktop*)patch_desktop, patch_desktop->base_context)) {\r\n    \r\n        Object_delete((Object*)patch_desktop->base_context);\r\n        Object_delete((Object*)patch_desktop);\r\n        return (PatchDesktop*)0;\r\n    }\r\n\r\n    Object_init((Object*)patch_desktop, PatchDesktop_delete_function);\r\n\r\n    patch_desktop->patch_core = patch_core;\r\n    patch_desktop->desktop.window.mouseclick_function = PatchDesktop_mouseclick_handler;\r\n    patch_desktop->desktop.window.mousemove_function = PatchDesktop_mousemove_handler;\r\n    patch_desktop->desktop.window.paint_function = PatchDesktop_paint_handler;\r\n    patch_desktop->desktop.mouse_shown = PlatformWrapper_is_mouse_shown();\r\n    patch_desktop->start_io = (IO*)0;\r\n    patch_desktop->menu = (SessionMenu*)0;\r\n\r\n    return patch_desktop;\r\n}\r\n\r\nvoid PatchDesktop_mouseclick_handler(Window* patch_desktop_window, int x, int y) {\r\n\r\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\r\n\r\n    patch_desktop->start_io = (IO*)0;\r\n\r\n    if(patch_desktop->menu) {\r\n\r\n        Object_delete((Object*)patch_desktop->menu);\r\n        patch_desktop->menu = (SessionMenu*)0;\r\n    } else {\r\n\r\n        patch_desktop->menu = SessionMenu_new(patch_desktop->patch_core, x, y);\r\n        Window_insert_child((Window*)patch_desktop, (Window*)patch_desktop->menu);\r\n    }\r\n}\r\n\r\nvoid draw_elbow(Context* context, int x1, int y1, int x2, int y2, uint32_t color) {\r\n\r\n    int hlen = x2 - x1;\r\n    int temp, vlen;\r\n\r\n    if(hlen < 0) {\r\n\r\n        temp = x1;\r\n        x1 = x2;\r\n        x2 = temp;\r\n        temp = y1;\r\n        y1 = y2;\r\n        y2 = temp;\r\n        hlen = -hlen;\r\n    }\r\n\r\n    Context_horizontal_line(context, x1, y1, hlen/2, color);\r\n    Context_horizontal_line(context, x1 + (hlen/2), y2, hlen/2, color);\r\n\r\n    vlen = y2 - y1;\r\n\r\n    if(vlen < 0) {\r\n\r\n        y1 = y2;\r\n        vlen = -vlen;\r\n    }\r\n\r\n    Context_vertical_line(context, x1 + (hlen/2), y1, vlen, color);\r\n}\r\n\r\nvoid PatchDesktop_paint_handler(Window* patch_desktop_window) {\r\n\r\n    int i;\r\n    IO* input;\r\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\r\n\r\n    Context_fill_rect(patch_desktop_window->context, 0, 0, patch_desktop_window->width,\r\n                      patch_desktop_window->height, RGB(90, 95, 210));\r\n\r\n    //Need an int to string function here (steal from calc)\r\n    Context_draw_text(patch_desktop_window->context, \"PATCH Build Number ?\",\r\n                      5, patch_desktop_window->height - 18, RGB(255, 255, 255));\r\n\r\n    if(patch_desktop->start_io) {\r\n\r\n        //TODO: really should implement clipped bresenham\r\n        draw_elbow(patch_desktop_window->context, Window_screen_x((Window*)patch_desktop->start_io) + 3,\r\n                   Window_screen_y((Window*)patch_desktop->start_io) + 3, patch_desktop->wire_x, \r\n                   patch_desktop->wire_y, RGB(200, 0, 0));\r\n    }\r\n\r\n    for(i = 0; i < patch_desktop->patch_core->inputs->count; i++) {\r\n\r\n        input = (IO*)List_get_at(patch_desktop->patch_core->inputs, i);\r\n\r\n        if(input->connected_io) {\r\n\r\n            draw_elbow(patch_desktop_window->context, Window_screen_x((Window*)input) + 3,\r\n                   Window_screen_y((Window*)input) + 3, Window_screen_x((Window*)input->connected_io), \r\n                   Window_screen_y((Window*)input->connected_io), RGB(0, 200, 0));\r\n        }\r\n    }\r\n}\r\n\r\nvoid PatchDesktop_connect_action(PatchDesktop* patch_desktop, IO* io) {\r\n\r\n    if(patch_desktop->start_io)\r\n        PatchDesktop_finish_connection(patch_desktop, io);\r\n    else\r\n        PatchDesktop_begin_connection(patch_desktop, io);\r\n}\r\n\r\nvoid PatchDesktop_begin_connection(PatchDesktop* patch_desktop, IO* io) {\r\n\r\n    patch_desktop->start_io = io;\r\n}\r\n\r\nvoid PatchDesktop_finish_connection(PatchDesktop* patch_desktop, IO* io) {\r\n\r\n    if(patch_desktop->start_io) {\r\n\r\n        //Guard against input-to-input and output-to-output\r\n        if((!!patch_desktop->start_io->is_output) == (!!io->is_output))\r\n            return;\r\n\r\n        IO_connect(patch_desktop->start_io, io);\r\n        IO_connect(io, patch_desktop->start_io);\r\n        patch_desktop->start_io = (IO*)0;\r\n        Window_invalidate((Window*)patch_desktop, 0, 0, patch_desktop->desktop.window.width - 1,\r\n                          patch_desktop->desktop.window.height - 1);\r\n    }\r\n}\r\n\r\nvoid PatchDesktop_end_connection(PatchDesktop* patch_desktop) {\r\n\r\n    patch_desktop->start_io = (IO*)0;\r\n}\r\n\r\nvoid PatchDesktop_mousemove_handler(Window* patch_desktop_window, int x, int y) {\r\n\r\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_window;\r\n\r\n    if(!patch_desktop->start_io)\r\n        return;\r\n\r\n    patch_desktop->wire_x = x;\r\n    patch_desktop->wire_y = y;\r\n    Window_invalidate((Window*)patch_desktop, 0, 0, patch_desktop->desktop.window.width - 1,\r\n                      patch_desktop->desktop.window.height - 1);\r\n}\r\n\r\nvoid PatchDesktop_delete_function(Object* patch_desktop_object) {\r\n\r\n    PatchDesktop* patch_desktop = (PatchDesktop*)patch_desktop_object;\r\n\r\n    if(!patch_desktop_object)\r\n        return;\r\n\r\n    Object_delete((Object*)patch_desktop->menu);\r\n    Window_delete_function(patch_desktop_object);\r\n}","#include \"menu.h\"\r\n\r\nMenu* Menu_new(int x, int y, int width) {\r\n\r\n    Menu* menu;\r\n    if(!(menu = (Menu*)malloc(sizeof(Menu))))\r\n        return menu;\r\n\r\n    if(!Menu_init(menu, x, y, width)) {\r\n\r\n        free(menu);\r\n        return (Menu*)0;\r\n    }\r\n\r\n    return menu;\r\n}\r\n\r\nint Menu_init(Menu* menu, int x, int y, int width) {\r\n\r\n    return Frame_init((Frame*)menu, x, y, width, 4);\r\n}\r\n\r\nvoid Menu_add_entry(Menu* menu, MenuEntry* menu_entry) {\r\n\r\n    Window_insert_child((Window*)menu, (Window*)menu_entry);\r\n    menu_entry->window.width = menu->frame.window.width - 4;\r\n    menu_entry->window.x = 2;\r\n    menu_entry->window.y = ((menu->frame.window.children->count - 1) * 14) + 2;\r\n    menu->frame.window.height += 14;\r\n}\r\n","#include \"platform/platformwrapper.h\"\r\n#include \"core/patchcore.h\"\r\n\r\nint main(int argc, char* argv[]) {\r\n\r\n    PlatformWrapper_init();\r\n    PatchCore_start(PatchCore_new());\r\n\r\n    PlatformWrapper_hold_for_exit();\r\n\r\n    return 0;\r\n}"]}